<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ScientificTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ScientificTypes.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy-1"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#Getting-started-1"><span>Getting started</span></a></li><li><a class="tocitem" href="#Summary-of-the-default-convention-1"><span>Summary of the default convention</span></a></li><li><a class="tocitem" href="#Notes-1"><span>Notes</span></a></li><li><a class="tocitem" href="#Type-coercion-for-tabular-data-1"><span>Type coercion for tabular data</span></a></li><li><a class="tocitem" href="#Type-coercion-for-image-data-1"><span>Type coercion for image data</span></a></li><li><a class="tocitem" href="#Detailed-usage-examples-1"><span>Detailed usage examples</span></a></li><li><a class="tocitem" href="#Automatic-type-conversion-1"><span>Automatic type conversion</span></a></li><li><a class="tocitem" href="#API-reference-1"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ScientificTypes.jl-1"><a class="docs-heading-anchor" href="#ScientificTypes.jl-1">ScientificTypes.jl</a><a class="docs-heading-anchor-permalink" href="#ScientificTypes.jl-1" title="Permalink"></a></h1><p>This package makes a distinction between <strong>machine type</strong> and <strong>scientific type</strong> of a Julia object:</p><ul><li><p>The <em>machine type</em> refers to the Julia type being used to represent the object (for instance, <code>Float64</code>).</p></li><li><p>The <em>scientific type</em> is one of the types defined in <a href="https://github.com/alan-turing-institute/ScientificTypesBase.jl">ScientificTypesBase.jl</a> reflecting how the object should be <em>interpreted</em> (for instance, <code>Continuous</code> or <code>Multiclass</code>).</p></li></ul><p>A <em>scientific type convention</em> is an assignment of a scientific type to every Julia object, articulated by overloading the <code>scitype</code> method.  The <code>DefaultConvention</code> convention is the convention used in various Julia ecosystems.</p><p>This package additionally defines tools for type coercion (the <code>coerce</code> method) and scientific type &quot;guessing&quot; (the <code>autotype</code> method).</p><p>Developers interested in implementing a different convention will instead import <a href="https://github.com/alan-turing-institute/ScientificTypesBase.jl">Scientific TypesBase.jl</a>, following the documentation there, possibly using this repo as a template.</p><h2 id="Type-hierarchy-1"><a class="docs-heading-anchor" href="#Type-hierarchy-1">Type hierarchy</a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy-1" title="Permalink"></a></h2><p>The supported scientific types have the following hierarchy:</p><pre><code class="language-none">Finite{N}
├─ Multiclass{N}
└─ OrderedFactor{N}

Infinite
├─ Continuous
└─ Count

Image{W,H}
├─ ColorImage{W,H}
└─ GrayImage{W,H}

ScientificTimeType
├─ ScientificDate
├─ ScientificTime
└─ ScientificDateTime

Table{K}

Textual

PersistenceDiagram

Unknown</code></pre><p>Additionally, we regard the Julia native types <code>Missing</code> and <code>Nothing</code> as scientific types as well.</p><h2 id="Getting-started-1"><a class="docs-heading-anchor" href="#Getting-started-1">Getting started</a><a class="docs-heading-anchor-permalink" href="#Getting-started-1" title="Permalink"></a></h2><p>This documentation focuses on properties of the <code>scitype</code> method specific to the default convention. The <code>scitype</code> method satisfies certain universal properties, with respect to its operation on tuples, arrays and tables, set out in the ScientificTypes <a href="https://github.com/JuliaAI/ScientificTypesBase.jl#2-the-scitype-and-scitype-methods">readme</a>, but only implicitly described here.</p><p>To get the scientific type of a Julia object defined by the default convention, call <code>scitype</code>:</p><pre><code class="language-julia-repl">julia&gt; using ScientificTypes

julia&gt; scitype(3.14)
Continuous</code></pre><p>For a vector, you can use <code>scitype</code> or <code>elscitype</code> (which will give you a scitype corresponding to the elements):</p><pre><code class="language-julia-repl">julia&gt; scitype([1,2,3,missing])
AbstractVector{Union{Missing, Count}} (alias for AbstractArray{Union{Missing, Count}, 1})</code></pre><pre><code class="language-julia-repl">julia&gt; elscitype([1,2,3,missing])
Union{Missing, Count}</code></pre><p>Occasionally, you may want to find the union of all scitypes of elements of an arbitrary iterable, which you can do with <code>scitype_union</code>:</p><pre><code class="language-julia-repl">julia&gt; scitype_union((ifelse(isodd(i), i, missing) for i in 1:5))
Union{Missing, Count}</code></pre><p>Note calling <code>scitype_union</code> on a large array, for example, is typically much slower than calling <code>scitype</code> or <code>elscitype</code>.</p><h2 id="Summary-of-the-default-convention-1"><a class="docs-heading-anchor" href="#Summary-of-the-default-convention-1">Summary of the default convention</a><a class="docs-heading-anchor-permalink" href="#Summary-of-the-default-convention-1" title="Permalink"></a></h2><p>The table below summarizes the default convention for representing scientific types:</p><table><tr><th style="text-align: left">Type <code>T</code></th><th style="text-align: left"><code>scitype(x)</code> for <code>x::T</code></th><th style="text-align: left">package required</th></tr><tr><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Nothing</code></td><td style="text-align: left"><code>Nothing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractFloat</code></td><td style="text-align: left"><code>Continuous</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>Count</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>String</code></td><td style="text-align: left"><code>Textual</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>Date</code></td><td style="text-align: left"><code>ScientificDate</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>Time</code></td><td style="text-align: left"><code>ScientificTime</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>DateTime</code></td><td style="text-align: left"><code>ScientificDateTime</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>AbstractArray{&lt;:Gray,2}</code></td><td style="text-align: left"><code>GrayImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left"><code>AbstractArrray{&lt;:AbstractRGB,2}</code></td><td style="text-align: left"><code>ColorImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left"><code>PersistenceDiagram</code></td><td style="text-align: left"><code>PersistenceDiagram</code></td><td style="text-align: left">PersistenceDiagramsBase</td></tr><tr><td style="text-align: left">any table type <code>T</code> supported by Tables.jl</td><td style="text-align: left"><code>Table{K}</code> where <code>K=Union{column_scitypes...}</code></td><td style="text-align: left">Tables</td></tr></table><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><h2 id="Notes-1"><a class="docs-heading-anchor" href="#Notes-1">Notes</a><a class="docs-heading-anchor-permalink" href="#Notes-1" title="Permalink"></a></h2><ul><li>We regard the built-in Julia types <code>Missing</code> and <code>Nothing</code> as scientific types.</li><li><code>Finite{N}</code>, <code>Multiclass{N}</code> and <code>OrderedFactor{N}</code> are all parameterized by the number of levels <code>N</code>. We export the alias <code>Binary = Finite{2}</code>.</li><li><code>Image{W,H}</code>, <code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parameterized by the image width and height dimensions, <code>(W, H)</code>.</li><li>On objects for which the default convention has nothing to say, the <code>scitype</code> function returns <code>Unknown</code>.</li></ul><h3 id="Special-note-on-binary-data-1"><a class="docs-heading-anchor" href="#Special-note-on-binary-data-1">Special note on binary data</a><a class="docs-heading-anchor-permalink" href="#Special-note-on-binary-data-1" title="Permalink"></a></h3><p>ScientificTypes does not define a separate &quot;binary&quot; scientific type. Rather, when binary data has an intrinsic &quot;true&quot; class (for example pass/fail in a product test), then it should be assigned an <code>OrderedFactor{2}</code> scitype, while data with no such class (e.g., gender) should be assigned a <code>Multiclass{2}</code> scitype. In the <code>OrderedFactor{2}</code> case we adopt the convention that the &quot;true&quot; class come <em>after</em> the &quot;false&quot; class in the ordering (corresponding to the usual assignment &quot;false=0&quot; and &quot;true=1&quot;). Of course, <code>Finite{2}</code> covers both cases of binary data.</p><h2 id="Type-coercion-for-tabular-data-1"><a class="docs-heading-anchor" href="#Type-coercion-for-tabular-data-1">Type coercion for tabular data</a><a class="docs-heading-anchor-permalink" href="#Type-coercion-for-tabular-data-1" title="Permalink"></a></h2><p>A common two-step work-flow is:</p><ol><li><p>Inspect the <code>schema</code> of some table, and the column <code>scitypes</code> in particular.</p></li><li><p>Provide pairs of column names and scitypes (or a dictionary) that change the column machine types to reflect the desired scientific interpretation (scitype).</p></li></ol><pre><code class="language-julia">using DataFrames, Tables
X = DataFrame(
	 name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
	 height=[152, missing, 148, 163],
	 rating=[1, 5, 2, 1])
schema(X)</code></pre><pre><code class="language-none">┌─────────┬───────────────────────┬───────────────────────┐
│ _.names │ _.types               │ _.scitypes            │
├─────────┼───────────────────────┼───────────────────────┤
│ name    │ String                │ Textual               │
│ height  │ Union{Missing, Int64} │ Union{Missing, Count} │
│ rating  │ Int64                 │ Count                 │
└─────────┴───────────────────────┴───────────────────────┘
_.nrows = 4
</code></pre><p>In some further analysis of the data in <code>X</code>, a more likely interpretation is that <code>:name</code> is <code>Multiclass</code>, the <code>:height</code> is <code>Continuous</code>, and the <code>:rating</code> an <code>OrderedFactor</code>. Correcting the types with <code>coerce</code>:</p><pre><code class="language-julia">Xfixed = coerce(X, :name=&gt;Multiclass,
                   :height=&gt;Continuous,
                   :rating=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Multiclass{4}, Union{Missing, Continuous}, OrderedFactor{3})</code></pre><p>Note that because missing values were encountered in <code>height</code>, an &quot;imperfect&quot; type coercion to <code>Union{Missing,Continuous}</code> has been performed, and a warning issued.  To avoid the warning, coerce to <code>Union{Missing,Continuous}</code> instead.</p><p>&quot;Global&quot; replacements based on existing scientific types are also possible, and can be mixed with the name-based replacements:</p><pre><code class="language-julia">X  = (x = [1, 2, 3],
      y = [&#39;A&#39;, &#39;B&#39;, &#39;A&#39;],
      z = [10, 20, 30])
Xfixed = coerce(X, Count=&gt;Continuous, :y=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Continuous, OrderedFactor{2}, Continuous)</code></pre><p>Finally there is a <code>coerce!</code> method that does in-place coercion provided the data structure supports it.</p><h2 id="Type-coercion-for-image-data-1"><a class="docs-heading-anchor" href="#Type-coercion-for-image-data-1">Type coercion for image data</a><a class="docs-heading-anchor-permalink" href="#Type-coercion-for-image-data-1" title="Permalink"></a></h2><p>To have a scientific type of <code>Image</code> a julia object must be a two-dimensional array whose element type is subtype of <code>Gray</code> or <code>AbstractRGB</code> (color types from the <a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a> package). And models typically expect <em>collections</em> of images to be vectors of such two-dimensional arrays. Implementations of <code>coerce</code> allow the conversion of some common image formats into one of these. The eltype in these other formats can be any subtype of <code>Real</code>, which includes the <code>FixedPoint</code> type from the <a href="https://github.com/JuliaMath/FixedPointNumbers.jl">FixedPointNumbers.jl</a> package.</p><h3 id="Coercing-a-single-image-1"><a class="docs-heading-anchor" href="#Coercing-a-single-image-1">Coercing a single image</a><a class="docs-heading-anchor-permalink" href="#Coercing-a-single-image-1" title="Permalink"></a></h3><p>Coercing a <strong>gray</strong> image, represented as a <code>Real</code> matrix (W x H format):</p><pre><code class="language-julia">img = rand(10, 10)
coerce(img, GrayImage) |&gt; scitype</code></pre><pre><code class="language-none">GrayImage{10, 10}</code></pre><p>Coercing a <strong>color</strong> image, represented as a <code>Real</code> 3-D array (W x H x C format):</p><pre><code class="language-julia">img = rand(10, 10, 3)
coerce(img, ColorImage) |&gt; scitype</code></pre><pre><code class="language-none">ColorImage{10, 10}</code></pre><h3 id="Coercing-collections-of-images-1"><a class="docs-heading-anchor" href="#Coercing-collections-of-images-1">Coercing collections of images</a><a class="docs-heading-anchor-permalink" href="#Coercing-collections-of-images-1" title="Permalink"></a></h3><p>Coercing a <strong>collection</strong> of <strong>gray</strong> images, represented as a <code>Real</code> 3-D array (W x H x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 3)
coerce(imgs, GrayImage) |&gt; scitype</code></pre><pre><code class="language-none">AbstractVector{GrayImage{10, 10}} (alias for AbstractArray{GrayImage{10, 10}, 1})</code></pre><p>Coercing a <strong>collection</strong> of <strong>gray</strong> images, represented as a <code>Real</code> 4-D array (W x H x {1} x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 1, 3)
coerce(imgs, GrayImage) |&gt; scitype</code></pre><pre><code class="language-none">AbstractVector{GrayImage{10, 10}} (alias for AbstractArray{GrayImage{10, 10}, 1})</code></pre><p>Coercing a <strong>collection</strong> of <strong>color</strong> images, represented as a <code>Real</code> 4-D array (W x H x C x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 3, 5)
coerce(imgs, ColorImage) |&gt; scitype</code></pre><pre><code class="language-none">AbstractVector{ColorImage{10, 10}} (alias for AbstractArray{ColorImage{10, 10}, 1})</code></pre><h2 id="Detailed-usage-examples-1"><a class="docs-heading-anchor" href="#Detailed-usage-examples-1">Detailed usage examples</a><a class="docs-heading-anchor-permalink" href="#Detailed-usage-examples-1" title="Permalink"></a></h2><h3 id="Basics-1"><a class="docs-heading-anchor" href="#Basics-1">Basics</a><a class="docs-heading-anchor-permalink" href="#Basics-1" title="Permalink"></a></h3><pre><code class="language-julia">using CategoricalArrays
scitype((2.718, 42))</code></pre><pre><code class="language-none">Tuple{Continuous, Count}</code></pre><p>In the default convention, to construct arrays with categorical scientific element type one needs to use <code>CategorialArrays</code>:</p><pre><code class="language-julia">v = categorical([&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, missing, &#39;b&#39;], ordered=true)
scitype(v[1])</code></pre><pre><code class="language-none">OrderedFactor{3}</code></pre><pre><code class="language-julia">elscitype(v)</code></pre><pre><code class="language-none">Union{Missing, OrderedFactor{3}}</code></pre><p>Coercing to <code>Multiclass</code>:</p><pre><code class="language-julia">w = coerce(v, Union{Missing,Multiclass})
elscitype(w)</code></pre><pre><code class="language-none">Union{Missing, Multiclass{3}}</code></pre><h3 id="Working-with-tables-1"><a class="docs-heading-anchor" href="#Working-with-tables-1">Working with tables</a><a class="docs-heading-anchor-permalink" href="#Working-with-tables-1" title="Permalink"></a></h3><p>While <code>schema</code> is convenient for inspecting the column scitypes of a table, there is also a scitype for the tables themselves:</p><pre><code class="language-julia">data = (x1=rand(10), x2=rand(10))
schema(data)</code></pre><pre><code class="language-none">┌─────────┬─────────┬────────────┐
│ _.names │ _.types │ _.scitypes │
├─────────┼─────────┼────────────┤
│ x1      │ Float64 │ Continuous │
│ x2      │ Float64 │ Continuous │
└─────────┴─────────┴────────────┘
_.nrows = 10
</code></pre><pre><code class="language-julia">scitype(data)</code></pre><pre><code class="language-none">Table{AbstractVector{Continuous}}</code></pre><p>Similarly, any table implementing the Tables interface has scitype <code>Table{K}</code>, where <code>K</code> is the union of the scitypes of its columns.</p><p>Table scitypes are useful for dispatch and type checks, as shown here, with the help of a constructor for <code>Table</code> scitypes provided by <a href="https://github.com/alan-turing-institute/ScientificTypes.jl">Scientific Types.jl</a>:</p><pre><code class="language-julia">Table(Continuous, Count)</code></pre><pre><code class="language-julia">Table{&lt;:Union{AbstractArray{&lt;:Continuous},AbstractArray{&lt;:Count}}}</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Continuous)</code></pre><pre><code class="language-none">true</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Infinite)</code></pre><pre><code class="language-none">true</code></pre><pre><code class="language-julia">data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])
data = coerce(data, :z=&gt;OrderedFactor)
scitype(data) &lt;: Table(Continuous,Count,OrderedFactor)</code></pre><pre><code class="language-none">true</code></pre><p>Note that <code>Table(Continuous,Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p><h3 id="Tuples-and-arrays-1"><a class="docs-heading-anchor" href="#Tuples-and-arrays-1">Tuples and arrays</a><a class="docs-heading-anchor-permalink" href="#Tuples-and-arrays-1" title="Permalink"></a></h3><p>The behavior of <code>scitype</code> on tuples is as you would expect:</p><pre><code class="language-julia">scitype((1, 4.5))</code></pre><pre><code class="language-none">Tuple{Count, Continuous}</code></pre><p>For performance reasons, the behavior of <code>scitype</code> on arrays has some wrinkles, in the case of missing values:</p><p><strong>The scitype of an array.</strong> The scitype of an <code>AbstractArray</code>, <code>A</code>, is always<code>AbstractArray{U}</code> where <code>U</code> is the union of the scitypes of the elements of <code>A</code>, with one exception: If <code>typeof(A) &lt;: AbstractArray{Union{Missing,T}}</code> for some <code>T</code> different from <code>Any</code>, then the scitype of <code>A</code> is <code>AbstractArray{Union{Missing, U}}</code>, where <code>U</code> is the union over all non-missing elements, <strong>even if <code>A</code> has no missing elements.</strong></p><pre><code class="language-julia">julia&gt; v = [1.3, 4.5, missing]
julia&gt; scitype(v)
AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">julia&gt; scitype(v[1:2])
AbstractArray{Union{Missing, Continuous},1}</code></pre><h2 id="Automatic-type-conversion-1"><a class="docs-heading-anchor" href="#Automatic-type-conversion-1">Automatic type conversion</a><a class="docs-heading-anchor-permalink" href="#Automatic-type-conversion-1" title="Permalink"></a></h2><p>The <code>autotype</code> function allows to use specific rules in order to guess appropriate scientific types for <em>tabular</em> data. Such rules would typically be more constraining than the ones implied by the active convention. When <code>autotype</code> is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as &quot;fallback&quot;.</p><p>The function is called as:</p><pre><code class="language-julia">autotype(X)</code></pre><p>If the keyword <code>only_changes</code> is passed set to <code>true</code>, then only the column names for which the suggested type is different from that provided by the convention are returned.</p><pre><code class="language-julia">autotype(X; only_changes=true)</code></pre><p>To specify which rules are to be applied, use the <code>rules</code> keyword  and specify a tuple of symbols referring to specific rules; the default rule is <code>:few_to_finite</code> which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate <code>Finite</code> type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.</p><pre><code class="language-julia">autotype(X; rules=(:few_to_finite,))</code></pre><p>Finally, you can also use the following shorthands:</p><pre><code class="language-julia">autotype(X, :few_to_finite)
autotype(X, (:few_to_finite, :discrete_to_continuous))</code></pre><h3 id="Available-rules-1"><a class="docs-heading-anchor" href="#Available-rules-1">Available rules</a><a class="docs-heading-anchor-permalink" href="#Available-rules-1" title="Permalink"></a></h3><table><tr><th style="text-align: left">Rule symbol</th><th style="text-align: left">scitype suggestion</th></tr><tr><td style="text-align: left"><code>:few_to_finite</code></td><td style="text-align: left">an appropriate <code>Finite</code> subtype for columns with few distinct values</td></tr><tr><td style="text-align: left"><code>:discrete_to_continuous</code></td><td style="text-align: left">if not <code>Finite</code>, then <code>Continuous</code> for any <code>Count</code> or <code>Integer</code> scitypes/types</td></tr><tr><td style="text-align: left"><code>:string_to_multiclass</code></td><td style="text-align: left"><code>Multiclass</code> for any string-like column</td></tr></table><p>Autotype can be used in conjunction with <code>coerce</code>:</p><pre><code class="language-none">X_coerced = coerce(X, autotype(X))</code></pre><h3 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h3><p>By default it only applies the <code>:few_to_finite</code> rule</p><pre><code class="language-julia">n = 50
X = (a = rand(&quot;abc&quot;, n),         # 3 values, not number        --&gt; Multiclass
     b = rand([1,2,3,4], n),     # 4 values, number            --&gt; OrderedFactor
     c = rand([true,false], n),  # 2 values, number but only 2 --&gt; Multiclass
     d = randn(n),               # many values                 --&gt; unchanged
     e = rand(collect(1:n), n))  # many values                 --&gt; unchanged
autotype(X, only_changes=true)</code></pre><pre><code class="language-none">Dict{Symbol, Type} with 3 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :c =&gt; OrderedFactor</code></pre><p>For example, we could first apply the <code>:discrete_to_continuous</code> rule, followed by <code>:few_to_finite</code> rule. The first rule will apply to <code>b</code> and <code>e</code> but the subsequent application of the second rule will mean we will get the same result apart for <code>e</code> (which will be <code>Continuous</code>)</p><pre><code class="language-julia">autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))</code></pre><pre><code class="language-none">Dict{Symbol, Type} with 4 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :e =&gt; Continuous
  :c =&gt; OrderedFactor</code></pre><p>One should check and possibly modify the returned dictionary before passing to <code>coerce</code>.</p><h2 id="API-reference-1"><a class="docs-heading-anchor" href="#API-reference-1">API reference</a><a class="docs-heading-anchor-permalink" href="#API-reference-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ScientificTypesBase.scitype" href="#ScientificTypesBase.scitype"><code>ScientificTypesBase.scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scitype(X)</code></pre><p>The scientific type (interpretation) of <code>X</code>, as distinct from its machine type, as specified by the active convention.</p><p><strong>Examples from the MLJ convention</strong></p><pre><code class="language-none">julia&gt; using ScientificTypes # or `using MLJ`
julia&gt; scitype(3.14)
Continuous

julia&gt; scitype([1, 2, 3, missing])
AbstractArray{Union{Missing, Count},1}

julia&gt; scitype((5, &quot;beige&quot;))
Tuple{Count, Textual}

julia&gt; using CategoricalArrays
julia&gt; X = (gender = categorical([&#39;M&#39;, &#39;M&#39;, &#39;F&#39;, &#39;M&#39;, &#39;F&#39;]),
            ndevices = [1, 3, 2, 3, 2])
julia&gt; scitype(X)
Table{Union{AbstractArray{Count,1}, AbstractArray{Multiclass{2},1}}}</code></pre><p>The specific behavior of <code>scitype</code> is governed by the active convention, as returned by <code>ScientificTypesBase.convention()</code>. The <a href="https://alan-turing-institute.github.io/ScientificTypes.jl/dev/">ScientificTypes.jl documentation</a> details the convention demonstrated above.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypesBase.elscitype" href="#ScientificTypesBase.elscitype"><code>ScientificTypesBase.elscitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elscitype(A)</code></pre><p>Return the element scientific type of an abstract array <code>A</code>. By definition, if <code>scitype(A) = AbstractArray{S,N}</code>, then <code>elscitype(A) = S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypesBase.scitype_union" href="#ScientificTypesBase.scitype_union"><code>ScientificTypesBase.scitype_union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scitype_union(A)</code></pre><p>Return the type union, over all elements <code>x</code> generated by the iterable <code>A</code>, of <code>scitype(x)</code>. See also <a href="#ScientificTypesBase.scitype"><code>scitype</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypes.coerce" href="#ScientificTypes.coerce"><code>ScientificTypes.coerce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coerce(A, specs...; tight=false, verbosity=1)</code></pre><p>Given a table <code>A</code>, return a copy of <code>A</code>, ensuring that the element scitypes of the columns match the new specification, <code>specs</code>. There are three valid specifiations:</p><p>(i) one or more <code>column_name=&gt;Scitype</code> pairs:</p><pre><code class="language-none">coerce(X, col1=&gt;Sciyype1, col2=&gt;Scitype2, ... ; verbosity=1)</code></pre><p>(ii) one or more <code>OldScitype=&gt;NewScitype</code> pairs (<code>OldScitype</code> covering both the <code>OldScitype</code> and <code>Union{Missing,OldScitype}</code> cases):</p><pre><code class="language-none">coerce(X, OldScitype1=&gt;NewSciyype1, OldScitype2=&gt;NewScitype2, ... ; verbosity=1)</code></pre><p>(iii) a dictionary of scientific types keyed on column names:</p><pre><code class="language-none">coerce(X, d::AbstractDict{Symbol, &lt;:Type}; verbosity=1)</code></pre><p><strong>Examples</strong></p><p>Specifiying  <code>column_name=&gt;Scitype</code> pairs:</p><pre><code class="language-none">using CategoricalArrays, DataFrames, Tables
X = DataFrame(name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
              height=[152, missing, 148, 163],
              rating=[1, 5, 2, 1])
Xc = coerce(X, :name=&gt;Multiclass, :height=&gt;Continuous, :rating=&gt;OrderedFactor)
schema(Xc).scitypes # (Multiclass, Continuous, OrderedFactor)</code></pre><p>Specifying <code>OldScitype=&gt;NewScitype</code> pairs:</p><pre><code class="language-none">X  = (x = [1, 2, 3],
      y = rand(3),
      z = [10, 20, 30])
Xc = coerce(X, Count=&gt;Continuous)
schema(Xfixed).scitypes # (Continuous, Continuous, Continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/a0d18af4c457661a7c6cfb2292533e96cfa0a216/src/coerce.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypes.autotype" href="#ScientificTypes.autotype"><code>ScientificTypes.autotype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">autotype(X; kw...)</code></pre><p>Return a dictionary of suggested scitypes for each column of <code>X</code>, a table or an array based on rules</p><p><strong>Kwargs</strong></p><ul><li><code>only_changes=true</code>:       if true, return only a dictionary of the names for                             which applying autotype differs from just using                             the ambient convention. When coercing with                             autotype, <code>only_changes</code> should be true.</li><li><code>rules=(:few_to_finite,)</code>: the set of rules to apply.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/a0d18af4c457661a7c6cfb2292533e96cfa0a216/src/autotype.jl#L1-L14">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 29 July 2021 04:21">Thursday 29 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
