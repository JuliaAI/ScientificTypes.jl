var documenterSearchIndex = {"docs":
[{"location":"#ScientificTypes.jl-1","page":"Home","title":"ScientificTypes.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A light-weight Julia interface for implementing conventions about the scientific interpretation of data, and for performing type coercions enforcing those conventions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package makes the distinction between between machine type and scientific type:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the machine type is a Julia type the data is currently encoded as (for instance: Float64)\nthe scientific type is a type defined by this package which encapsulates how the data should be interpreted in the rest of the code (for instance: Continuous or Multiclass)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a motivating example, the data might contain a column corresponding to a number of transactions, the machine type in that case could be an Int whereas the scientific type would be a Count.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The usefulness of this machinery becomes evident when the machine type does not directly connect with a scientific type; taking the previous example, the data could have been encoded as a Float64 whereas the meaning should still be a Count.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package  ScientificTypes provides:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A hierarchy of new Julia types representing scientific data types for use in method dispatch (eg, for trait values). Instances of the types play no role:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Found\n├─ Known\n│  ├─ Finite\n│  │  ├─ Multiclass\n│  │  └─ OrderedFactor\n│  ├─ Infinite\n│  │  ├─ Continuous\n│  │  └─ Count\n│  ├─ Image\n│  │  ├─ ColorImage\n│  │  └─ GrayImage\n│  └─ Table\n└─ Unknown","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A single method scitype for articulating a convention about what scientific type each Julia object can represent. For example, one might declare scitype(::AbstractFloat) = Continuous.\nA default convention called MLJ, based on dependencies CategoricalArrays, ColorTypes, and Tables, which includes a convenience method coerce for performing scientific type coercion on AbstractVectors and columns of tabular data (any table implementing the Tables.jl interface).\nA schema method for tabular data, based on the optional Tables dependency, for inspecting the machine and scientific types of tabular data, in addition to column names and number of rows.","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package is registered and can be installed via the package manager with add ScientificTypes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get the scientific type of a Julia object according to the convention in use, call scitype:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes # hide\nscitype(3.14)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a vector, you can use scitype or scitype_union (which will give you a scitype corresponding to the elements):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype([1,2,3,missing])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype_union([1,2,3,missing])","category":"page"},{"location":"#Type-coercion-work-flow-for-tabular-data-1","page":"Home","title":"Type coercion work-flow for tabular data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The standard workflow involves the following two steps:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"inspect the schema of the data and the scitypes in particular\nprovide pairs or a dictionary with column names and scitypes for any changes you may want and coerce the data to those scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes # hide\nusing DataFrames, Tables\nX = DataFrame(\n     name=[\"Siri\", \"Robo\", \"Alexa\", \"Cortana\"],\n     height=[152, missing, 148, 163],\n     rating=[1, 5, 2, 1])\nschema(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"inspecting the scitypes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"schema(X).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"but in this case you may want to map the names to Multiclass, the height to Continuous and the ratings to OrderedFactor; to do so:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Xfixed = coerce(X, :name=>Multiclass,\n                   :height=>Continuous,\n                   :rating=>OrderedFactor)\nschema(Xfixed).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that, as it encountered missing values in height it coerced the type to Union{Missing,Continuous}.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One can also make a replacement based on existing scientific type, instead of feature name:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"X  = (x = [1, 2, 3],\n      y = rand(3),\n      z = [10, 20, 30])\nXfixed = coerce(X, Count=>Continuous)\nschema(Xfixed).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally there is a coerce! method that does in-place coercion provided the data structure allows it (at the moment only DataFrames.DataFrame is supported).","category":"page"},{"location":"#Notes-1","page":"Home","title":"Notes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We regard the built-in Julia type Missing as a scientific type. The new scientific types introduced in the current package are rooted in the abstract type Found (see tree above) and you export the alias Scientific = Union{Missing, Found}.\nFinite{N}, Multiclass{N} and OrderedFactor{N} are all parametrised by the number of levels N. We export the alias Binary = Finite{2}.\nImage{W,H}, GrayImage{W,H} and ColorImage{W,H} are all parametrised by the image width and height dimensions, (W, H).\nThe function scitype has the fallback value Unknown.\nSince Tables is an optional dependency, the scitype of a Tables.jl supported table is Unknown unless Tables has been imported.\nDevelopers can define their own conventions using the code in src/conventions/mlj/ as a template. The active convention is controlled by the value of ScientificTypes.CONVENTION[1].","category":"page"},{"location":"#Special-note-on-binary-data-1","page":"Home","title":"Special note on binary data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ScientificTypes does not define a separate \"binary\" scientific type. Rather, when binary data has an intrinsic \"true\" class (for example pass/fail in a product test), then it should be assigned an OrderedFactor{2} scitype, while data with no such class (e.g., gender) should be assigned a Multiclass{2} scitype. In the former case we recommend that the \"true\" class come after \"false\" in the ordering (corresponding to the usual assignment \"false=0\" and \"true=1\"). Of course, Finite{2} covers both cases of binary data.","category":"page"},{"location":"#Detailed-usage-examples-1","page":"Home","title":"Detailed usage examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes\n# activate a convention\nScientificTypes.set_convention(MLJ) # redundant as it's the default\n\nscitype((2.718, 42))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Let's try with categorical valued objects:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using CategoricalArrays\nv = categorical(['a', 'c', 'a', missing, 'b'], ordered=true)\nscitype(v[1])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype_union(v)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"you could coerce this to Multiclass:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"w = coerce(v, Multiclass)\nscitype_union(w)","category":"page"},{"location":"#Working-with-tables-1","page":"Home","title":"Working with tables","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes # hide\nusing Tables\ndata = (x1=rand(10), x2=rand(10), x3=collect(1:10))\nscitype(data)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"you can also use schema:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"schema(data)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and use <: for type checks:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(data) <: Table(Continuous)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(data) <: Table(Infinite)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or specify multiple types directly:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])\ndata = coerce(data, :z=>OrderedFactor)\nscitype(data) <: Table(Continuous,Count,OrderedFactor)","category":"page"},{"location":"#The-scientific-type-of-tuples,-arrays-and-tables-1","page":"Home","title":"The scientific type of tuples, arrays and tables","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Under any convention, the scitype of a tuple is a Tuple type parameterized by scientific types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes # hide\nscitype((1, 4.5))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Similarly, the scitype of an AbstractArray is AbstractArray{U} where U is the union of the element scitypes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype([1.3, 4.5, missing])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Performance note: Computing type unions over large arrays is expensive and, depending on the convention's implementation and the array eltype, computing the scitype can be slow. (In the MLJ convention this is mitigated with the help of the ScientificTypes.Scitype method, of which other conventions could make use. Do ?ScientificTypes.Scitype for details.) An eltype Any will always be slow and you may want to consider replacing an array A with broadcast(identity, A) to collapse the eltype and speed up the computation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Provided the Tables.jl package is loaded, any table implementing the Tables interface has a scitype encoding the scitypes of its columns:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using CategoricalArrays, Tables\nX = (x1=rand(10),\n     x2=rand(10),\n     x3=categorical(rand(\"abc\", 10)),\n     x4=categorical(rand(\"01\", 10)))\nscitype(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Sepcifically, if X has columns c1, ..., cn, then, by definition,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) == Table{Union{scitype(c1), ..., scitype(cn)}}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With this definition, common type checks can be performed with tables. For instance, you could check that each column of X has an element scitype that is either Continuous or Finite:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) <: Table{<:Union{AbstractVector{<:Continuous}, AbstractVector{<:Finite}}}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A built-in Table constructor provides a shorthand for the right-hand side:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) <: Table(Continuous, Finite)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that Table(Continuous,Finite) is a type union and not a Table instance.","category":"page"},{"location":"#The-MLJ-convention-1","page":"Home","title":"The MLJ convention","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The table below summarizes the MLJ convention for representing scientific types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Type T scitype(x) for x::T package required\nMissing Missing \nAbstractFloat Continuous \nInteger Count \nCategoricalValue Multiclass{N} where N = nlevels(x), provided x.pool.ordered == false CategoricalArrays\nCategoricalString Multiclass{N} where N = nlevels(x), provided x.pool.ordered == false CategoricalArrays\nCategoricalValue OrderedFactor{N} where N = nlevels(x), provided x.pool.ordered == true CategoricalArrays\nCategoricalString OrderedFactor{N} where N = nlevels(x) provided x.pool.ordered == true CategoricalArrays\nAbstractArray{<:Gray,2} GrayImage{W,H} where (W, H) = size(x) ColorTypes\nAbstractArrray{<:AbstractRGB,2} ColorImage{W,H} where (W, H) = size(x) ColorTypes\nany table type T supported by Tables.jl Table{K} where K=Union{column_scitypes...} Tables","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here nlevels(x) = length(levels(x.pool)).","category":"page"},{"location":"#Automatic-type-conversion-for-tabular-data-1","page":"Home","title":"Automatic type conversion for tabular data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The autotype function allows to use specific rules in order to guess appropriate scientific types for the data. Such rules would typically be more constraining than the ones implied by the active convention. When autotype is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as \"fallback\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The function is called as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If the keyword only_changes is passed set to true, then only the column names for which the suggested type is different from that provided by the convention are returned.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X; only_changes=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To specify which rules are to be applied, use the rules keyword  and specify a tuple of symbols referring to specific rules; the default rule is :few_to_finite which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate Finite type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X; rules=(:few_to_finite,))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, you can also use the following shorthands:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X, :few_to_finite)\nautotype(X, (:few_to_finite, :discrete_to_continuous))","category":"page"},{"location":"#Available-rules-1","page":"Home","title":"Available rules","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Rule symbol scitype suggestion\n:few_to_finite an appropriate Finite subtype for columns with few distinct values\n:discrete_to_continuous if not Finite, then Continuous for any Count or Integer scitypes/types\n:string_to_multiclass Multiclass for any string-like column","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Autotype can be used in conjunction with coerce:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"X_coerced = coerce(X, autotype(X))","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"By default it only applies the :few_to_many rule","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using ScientificTypes, Tables # hide\nn = 50\nX = (a = rand(\"abc\", n),         # 3 values, not number        --> Multiclass\n     b = rand([1,2,3,4], n),     # 4 values, number            --> OrderedFactor\n     c = rand([true,false], n),  # 2 values, number but only 2 --> Multiclass\n     d = randn(n),               # many values                 --> unchanged\n     e = rand(collect(1:n), n))  # many values                 --> unchanged\nautotype(X, only_changes=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For example, we could first apply the :discrete_to_continuous rule, followed by :few_to_finite rule. The first rule will apply to b and e but the subsequent application of the second rule will mean we will get the same result apart for e (which will be Continuous)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One should check and possibly modify the returned dictionary before passing to coerce.","category":"page"}]
}
