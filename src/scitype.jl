"""
scitype(X)

The scientific type that `X` may represent.
"""
scitype(X;    kw...) = scitype(X, convention();     kw...)
scitype(X, C; kw...) = scitype(X, C, Val(trait(X)); kw...)

scitype(X, C, ::Val{:other}; kw...) = Unknown
scitype(::Missing;           kw...) = Missing


# ## CONVENIENCE METHOD FOR UNIONS OVER ELEMENTS

"""
scitype_union(A)

Return the type union, over all elements `x` generated by the iterable
`A`, of `scitype(x)`.

See also [`scitype`](@ref).
"""
scitype_union(A) = reduce((a,b)->Union{a,b}, (scitype(el) for el in A))


# ## SCITYPES OF TUPLES

scitype(t::Tuple, ::Convention; kw...) = Tuple{scitype.(t; kw...)...}


# ## SCITYPES OF ARRAYS

"""
ScientificTypes.Scitype(::Type, ::C)

Method for implementers of a convention `C` to enable speed-up of
scitype evaluations for large arrays.

In general, one cannot infer the scitype of an object of type
`AbstractArray{T, N}` from the machine type alone. For, example, this
never holds in the *MLJ* convention for a categorical array, or in the
following examples: `X=Any[1, 2, 3]` and `X=Union{Missing,Int64}[1, 2, 3]`.

Nevertheless, for some *restricted* machine types `U`, the statement
`type(X) == AbstractArray{T, N}` for some `T<:U` already allows one
deduce that `scitype(X) = AbstractArray{S,N}`, where `S` is determined
by `U` alone. This is the case in the *MLJ* convention, for example,
if `U = Integer`, in which case `S = Count`. If one explicitly declares

    ScientificTypes.Scitype(::Type{<:U}, ::C) = S

in such cases, then ScientificTypes ensures a considerable speed-up in
the computation of `scitype(X)`. There is also a partial speed-up for
the case that `T <: Union{U, Missing}`.

For example, in the *MLJ* convention, one has
`Scitype(::Type{<:Integer}, ::MLJ) = Count`.

""" # XXX
Scitype(::Type, ::Convention) = Unknown
# to distinguish between Any type and Union{T,Missing} for some more
# specialised `T`, we define the Any case explicitly
Scitype(::Type{Any}, ::Convention) = Unknown

# For all such `T` we can also get almost the same speed-up in the case that
# `T` is replaced by `Union{T, Missing}`, which we detect by wrapping
# the answer as a Val:

Scitype(::Type{Union{T,Missing}}, C::Convention) where T =
    Union{Missing,Scitype(T, C)}

# For example, Scitype(::Integer, ::MLJ) = Count

# the dispatcher:
scitype(A::Arr{T}, C, ::Val{:other}; kw...) where T =
    arr_scitype(A, C, Scitype(T, C); kw...)

function arr_scitype(A::Arr{T,N}, C::Convention, S;
                     tight::Bool=false) where {T,N}
    # no explicit scitype available
    S === Unknown && return Arr{scitype_union(A),N}
    # otherwise return `Arr{S,N}` or `Arr{Union{Missing,S},N}`
    if T >: Missing
        if tight
            has_missings = findfirst(ismissing, A) !== nothing
            !has_missings && return Arr{nonmissing(S),N}
        end
        return Arr{Union{S,Missing},N}
    end
    return Arr{S,N}
end

"""
elscitype(A)

Return the scitype of elements of A. Unlike `scitype_union`, this does, in
general, not check the scitype of each element, rather it takes the global
scitype which is `AbstractArray{T,N}` and extracts the element scitype from
the `T`. Note however that, in some corner cases, `scitype` does check all
elements in which case `elscitype` also will.
"""
elscitype(X::Arr; kw...) = scitype(X; kw...) |> _get_elst

_get_elst(st::Type{Arr{T,N}}) where {T,N} = T
