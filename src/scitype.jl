"""
scitype(X)

The scientific type that `x` may represent.
"""
scitype(X) = scitype(X, Val(convention()))
scitype(X, C) = scitype(X, C, Val(trait(X)))
scitype(X, C, ::Val{:other}) = Unknown

scitype(::Missing) = Missing

# ## CONVENIENCE METHOD FOR UNIONS OVER ELEMENTS

"""
scitype_union(A)

Return the type union, over all elements `x` generated by the iterable
`A`, of `scitype(x)`.

See also `scitype`.
"""
scitype_union(A) = reduce((a,b)->Union{a,b}, (scitype(el) for el in A))


# ## SCITYPES OF TUPLES

scitype(t::Tuple, ::Val) = Tuple{scitype.(t)...}


# ## SCITYPES OF ARRAYS

"""
ScientificTypes.Scitype(::Type, C::Val)

Method for implementers of a conventions to enable speed-up of scitype
evaluations for large arrays.

In general, one cannot infer the scitype of an object of type
`AbstractArray{T, N}` from the machine type alone. For, example, this
never holds in the *mlj* convention for a categorical array, or in the
following examples: `X=Any[1, 2, 3]` and `X=Union{Missing,Int64}[1, 2,
3]`.

Nevertheless, for some *restricted* machine types `U`, the statement
`type(X) == AbstractArray{T, N}` for some `T<:U` already allows one
deduce that `scitype(X) = AbstractArray{S,N}`, where `S` is determined
by `U` alone. This is the case in the *mlj* convention, for example,
if `U = Integer`, in which case `S = Count`. If one explicitly declares

    ScientificTypes.Scitype(::Type{<:U}, ::Val{:convention}) = S

in such cases, then ScientificTypes ensures a considerable speed-up in
the computation of `scitype(X)`. There is also a partial speed-up for
the case that `T <: Union{U, Missing}`.

For example, in *mlj* one has `Scitype(::Type{<:Integer}) = Count`.

"""
Scitype(::Type, C::Val) = nothing
Scitype(::Type{Any}, C::Val) = nothing # b/s `Any` isa `Union{<:Any, Missing}`

# For all such `T` we can also get almost the same speed-up in the case that
# `T` is replaced by `Union{T, Missing}`, which we detect by wrapping
# the answer as a Val:

Scitype(MT::Type{Union{T, Missing}}, C::Val) where T = Val(Scitype(T, C))

# For example, in *mlj* convention, Scitype(::Integer) = Count

const Arr{T,N} = AbstractArray{T,N}

# the dispatcher:
scitype(A::Arr{T}, C, ::Val{:other}) where T = arr_scitype(A, C, Scitype(T, C))

# the slow fallback:
arr_scitype(A::Arr{<:Any,N}, ::Val, ::Nothing) where N =
    AbstractArray{scitype_union(A),N}

# the speed-up:
arr_scitype(::Arr{<:Any,N}, ::Val, S) where N = Arr{S,N}

# partial speed-up for missing types, because broadcast is faster than
# computing scitype_union:
function arr_scitype(A::Arr{<:Any,N}, C::Val, ::Val{S}) where {N,S}
    if S == nothing
        return arr_scitype(A, C, S)
    else
        Atight = broadcast(identity, A)
        if typeof(A) == typeof(Atight)
            return Arr{Union{S,Missing},N}
        else
            return Arr{S,N}
        end
    end
end


_get_elscitype(st::Type{AbstractArray{T,N}}) where {T,N} = T

"""
elscitype(A)

Return the scitype of elements of A. Unlike `scitype_union`, this does, in
general, not check the scitype of each element, rather it takes the global
scitype which is `AbstractArray{T,N}` and extracts the element scitype from
the `T`. Note however that, in some corner cases, `scitype` does check all
elements in which case `elscitype` also will.
"""
elscitype(X::AbstractArray) = scitype(X) |> _get_elscitype
