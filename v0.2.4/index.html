<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ScientificTypes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ScientificTypes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Getting-started-1">Getting started</a></li><li><a class="toctext" href="#Notes-1">Notes</a></li><li><a class="toctext" href="#Detailed-usage-examples-1">Detailed usage examples</a></li><li><a class="toctext" href="#The-MLJ-convention-1">The MLJ convention</a></li><li><a class="toctext" href="#Automatic-type-conversion-for-tabular-data-1">Automatic type conversion for tabular data</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/ScientificTypes.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ScientificTypes.jl-1" href="#ScientificTypes.jl-1">ScientificTypes.jl</a></h1><p>A light-weight Julia interface for implementing conventions about the scientific interpretation of data, and for performing type coercions enforcing those conventions.</p><p>The package makes the distinction between between <strong>machine type</strong> and <strong>scientific type</strong>:</p><ul><li>the <em>machine type</em> is a Julia type the data is currently encoded as (for instance: <code>Float64</code>)</li><li>the <em>scientific type</em> is a type defined by this package which encapsulates how the data should be <em>interpreted</em> in the rest of the code (for instance: <code>Continuous</code> or <code>Multiclass</code>)</li></ul><p>As a motivating example, the data might contain a column corresponding to a <em>number of transactions</em>, the machine type in that case could be an <code>Int</code> whereas the scientific type would be a <code>Count</code>.</p><p>The usefulness of this machinery becomes evident when the machine type does not directly connect with a scientific type; taking the previous example, the data could have been encoded as a <code>Float64</code> whereas the meaning should still be a <code>Count</code>.</p><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><p>The package  <code>ScientificTypes</code> provides:</p><ul><li>A hierarchy of new Julia types representing scientific data types for use in method dispatch (eg, for trait values). Instances of the types play no role:</li></ul><pre><code class="language-none">Found
├─ Known
│  ├─ Finite
│  │  ├─ Multiclass
│  │  └─ OrderedFactor
│  ├─ Infinite
│  │  ├─ Continuous
│  │  └─ Count
│  ├─ Image
│  │  ├─ ColorImage
│  │  └─ GrayImage
│  └─ Table
└─ Unknown</code></pre><ul><li><p>A single method <code>scitype</code> for articulating a convention about what scientific type each Julia object can represent. For example, one might declare <code>scitype(::AbstractFloat) = Continuous</code>.</p></li><li><p>A default convention called <em>mlj</em>, based on dependencies <code>CategoricalArrays</code>, <code>ColorTypes</code>, and <code>Tables</code>, which includes a convenience method <code>coerce</code> for performing scientific type coercion on <code>AbstractVectors</code> and columns of tabular data (any table implementing the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface).</p></li><li><p>A <code>schema</code> method for tabular data, based on the optional Tables dependency, for inspecting the machine and scientific types of tabular data, in addition to column names and number of rows.</p></li></ul><h2><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h2><p>The package is registered and can be installed via the package manager with <code>add ScientificTypes</code>.</p><p>To get the scientific type of a Julia object according to the convention in use, call <code>scitype</code>:</p><pre><code class="language-julia">scitype(3.14)</code></pre><pre><code class="language-none">Continuous</code></pre><p>For a vector, you can use <code>scitype</code> or <code>scitype_union</code> (which will give you a scitype corresponding to the elements):</p><pre><code class="language-julia">scitype([1,2,3,missing])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Count},1}</code></pre><pre><code class="language-julia">scitype_union([1,2,3,missing])</code></pre><pre><code class="language-none">Union{Missing, Count}</code></pre><h3><a class="nav-anchor" id="Type-coercion-work-flow-for-tabular-data-1" href="#Type-coercion-work-flow-for-tabular-data-1">Type coercion work-flow for tabular data</a></h3><p>The standard workflow involves the following two steps:</p><ol><li>inspect the <code>schema</code> of the data and the <code>scitypes</code> in particular</li><li>provide pairs or a dictionary with column names and scitypes for any changes you may want and coerce the data to those scitypes</li></ol><pre><code class="language-julia">using DataFrames, Tables
X = DataFrame(
     name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
     height=[152, missing, 148, 163],
     rating=[1, 5, 2, 1])
schema(X)</code></pre><pre><code class="language-none">(names = (:name, :height, :rating), types = (String, Union{Missing, Int64}, Int64), scitypes = (Unknown, Union{Missing, Count}, Count), nrows = 4)</code></pre><p>inspecting the scitypes:</p><pre><code class="language-julia">schema(X).scitypes</code></pre><pre><code class="language-none">(Unknown, Union{Missing, Count}, Count)</code></pre><p>but in this case you may want to map the names to <code>Multiclass</code>, the height to <code>Continuous</code> and the ratings to <code>OrderedFactor</code>; to do so:</p><pre><code class="language-julia">Xfixed = coerce(X, :name=&gt;Multiclass,
                   :height=&gt;Continuous,
                   :rating=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Multiclass{4}, Union{Missing, Continuous}, OrderedFactor{3})</code></pre><p>Note that, as it encountered missing values in <code>height</code> it coerced the type to <code>Union{Missing,Continuous}</code>.</p><h2><a class="nav-anchor" id="Notes-1" href="#Notes-1">Notes</a></h2><ul><li><p>We regard the built-in julia type <code>Missing</code> as a scientific type. The new scientific types introduced in the current package are rooted in the abstract type <code>Found</code> (see tree above) and you export the alias <code>Scientific = Union{Missing, Found}</code>.</p></li><li><p><code>Finite{N}</code>, <code>Muliticlass{N}</code> and <code>OrderedFactor{N}</code> are all parameterized by the number of levels <code>N</code>. We export the alias <code>Binary = Finite{2}</code>.</p></li><li><p><code>Image{W,H}</code>, <code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parameterized by the image width and height dimensions, <code>(W, H)</code>.</p></li><li><p>The function <code>scitype</code> has the fallback value <code>Unknown</code>.</p></li><li><p>Since Tables is an optional dependency, the <code>scitype</code> of a <a href="https://github.com/JuliaData/Tables.jl"><code>Tables.jl</code></a> supported table is <code>Unknown</code> unless Tables has been imported.</p></li><li><p>Developers can define their own conventions using the code in <code>src/conventions/mlj/</code> as a template. The active convention is controlled by the value of <code>ScientificTypes.CONVENTION[1]</code>.</p></li></ul><h2><a class="nav-anchor" id="Detailed-usage-examples-1" href="#Detailed-usage-examples-1">Detailed usage examples</a></h2><pre><code class="language-julia">using ScientificTypes
# activate a convention
mlj() # redundant as it&#39;s the default

scitype((2.718, 42))</code></pre><pre><code class="language-none">Tuple{Continuous,Count}</code></pre><p>Let&#39;s try with categorical valued objects:</p><pre><code class="language-julia">using CategoricalArrays
v = categorical([&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, missing, &#39;b&#39;], ordered=true)
scitype(v[1])</code></pre><pre><code class="language-none">OrderedFactor{3}</code></pre><p>and</p><pre><code class="language-julia">scitype_union(v)</code></pre><pre><code class="language-none">Union{Missing, OrderedFactor{3}}</code></pre><p>you could coerce this to <code>Multiclass</code>:</p><pre><code class="language-julia">w = coerce(v, Multiclass)
scitype_union(w)</code></pre><pre><code class="language-none">Union{Missing, Multiclass{3}}</code></pre><h3><a class="nav-anchor" id="Working-with-tables-1" href="#Working-with-tables-1">Working with tables</a></h3><pre><code class="language-julia">using Tables
data = (x1=rand(10), x2=rand(10), x3=collect(1:10))
scitype(data)</code></pre><pre><code class="language-none">Table{Union{AbstractArray{Continuous,1}, AbstractArray{Count,1}}}</code></pre><p>you can also use <code>schema</code>:</p><pre><code class="language-julia">schema(data)</code></pre><pre><code class="language-none">(names = (:x1, :x2, :x3), types = (Float64, Float64, Int64), scitypes = (Continuous, Continuous, Count), nrows = 10)</code></pre><p>and use <code>&lt;:</code> for type checks:</p><pre><code class="language-julia">scitype(data) &lt;: Table(Continuous)</code></pre><pre><code class="language-none">false</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Infinite)</code></pre><pre><code class="language-none">true</code></pre><p>or specify multiple types directly:</p><pre><code class="language-julia">data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])
data = coerce(data, :z=&gt;OrderedFactor)
scitype(data) &lt;: Table(Continuous,Count,OrderedFactor)</code></pre><pre><code class="language-none">true</code></pre><h3><a class="nav-anchor" id="The-scientific-type-of-tuples,-arrays-and-tables-1" href="#The-scientific-type-of-tuples,-arrays-and-tables-1">The scientific type of tuples, arrays and tables</a></h3><p>Under any convention, the scitype of a tuple is a <code>Tuple</code> type parameterized by scientific types:</p><pre><code class="language-julia">scitype((1, 4.5))</code></pre><pre><code class="language-none">Tuple{Count,Continuous}</code></pre><p>Similarly, the scitype of an <code>AbstractArray</code> is <code>AbstractArray{U}</code> where <code>U</code> is the union of the element scitypes:</p><pre><code class="language-julia">scitype([1.3, 4.5, missing])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Continuous},1}</code></pre><p><em>Performance note:</em> Computing type unions over large arrays is expensive and, depending on the convention&#39;s implementation and the array eltype, computing the scitype can be slow. (In the <em>mlj</em> convention this is mitigated with the help of the <code>ScientificTypes.Scitype</code> method, of which other conventions could make use. Do <code>?ScientificTypes.Scitype</code> for details.) An eltype <code>Any</code> will always be slow and you may want to consider replacing an array <code>A</code> with <code>broadcast(idenity, A)</code> to collapse the eltype and speed up the computation.</p><p>Provided the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> package is loaded, any table implementing the Tables interface has a scitype encoding the scitypes of its columns:</p><pre><code class="language-julia">using CategoricalArrays, Tables
X = (x1=rand(10),
     x2=rand(10),
     x3=categorical(rand(&quot;abc&quot;, 10)),
     x4=categorical(rand(&quot;01&quot;, 10)))
scitype(X)</code></pre><pre><code class="language-none">Table{Union{AbstractArray{Continuous,1}, AbstractArray{Multiclass{3},1}, AbstractArray{Multiclass{2},1}}}</code></pre><p>Sepcifically, if <code>X</code> has columns <code>c1, ..., cn</code>, then, by definition,</p><pre><code class="language-julia">scitype(X) == Table{Union{scitype(c1), ..., scitype(cn)}}</code></pre><p>With this definition, common type checks can be performed with tables. For instance, you could check that each column of <code>X</code> has an element scitype that is either <code>Continuous</code> or <code>Finite</code>:</p><pre><code class="language-julia">scitype(X) &lt;: Table{&lt;:Union{AbstractVector{&lt;:Continuous}, AbstractVector{&lt;:Finite}}}</code></pre><pre><code class="language-none">true</code></pre><p>A built-in <code>Table</code> constructor provides a shorthand for the right-hand side:</p><pre><code class="language-julia">scitype(X) &lt;: Table(Continuous, Finite)</code></pre><pre><code class="language-none">true</code></pre><p>Note that <code>Table(Continuous,Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p><h2><a class="nav-anchor" id="The-MLJ-convention-1" href="#The-MLJ-convention-1">The MLJ convention</a></h2><p>The table below summarizes the <em>mlj</em> convention for representing scientific types:</p><table><tr><th style="text-align: left">Type <code>T</code></th><th style="text-align: left"><code>scitype(x)</code> for <code>x::T</code></th><th style="text-align: left">package required</th></tr><tr><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractFloat</code></td><td style="text-align: left"><code>Continuous</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>Count</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>AbstractArray{&lt;:Gray,2}</code></td><td style="text-align: left"><code>GrayImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left"><code>AbstractArrray{&lt;:AbstractRGB,2}</code></td><td style="text-align: left"><code>ColorImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left">any table type <code>T</code> supported by Tables.jl</td><td style="text-align: left"><code>Table{K}</code> where <code>K=Union{column_scitypes...}</code></td><td style="text-align: left">Tables</td></tr></table><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><h2><a class="nav-anchor" id="Automatic-type-conversion-for-tabular-data-1" href="#Automatic-type-conversion-for-tabular-data-1">Automatic type conversion for tabular data</a></h2><p>The <code>autotype</code> function allows to use specific rules in order to guess appropriate scientific types for the data. Such rules would typically be more constraining than the ones implied by the active convention. When <code>autotype</code> is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as &quot;fallback&quot;.</p><p>The function is called as:</p><pre><code class="language-julia">autotype(X)</code></pre><p>If the keyword <code>only_changes</code> is passed set to <code>true</code>, then only the column names for which the suggested type is different from that provided by the convention are returned.</p><pre><code class="language-julia">autotype(X; only_changes=true)</code></pre><p>To specify which rules are to be applied, use the <code>rules</code> keyword  and specify a tuple of symbols referring to specific rules; the default rule is <code>:few_to_finite</code> which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate <code>Finite</code> type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.</p><pre><code class="language-julia">autotype(X; rules=(:few_to_finite,))</code></pre><h3><a class="nav-anchor" id="Available-rules-1" href="#Available-rules-1">Available rules</a></h3><table><tr><th style="text-align: left">Rule symbol</th><th style="text-align: left">scitype suggestion</th></tr><tr><td style="text-align: left"><code>:few_to_finite</code></td><td style="text-align: left">an appropriate <code>Finite</code> subtype for columns with few distinct values</td></tr><tr><td style="text-align: left"><code>:discrete_to_continuous</code></td><td style="text-align: left">if not <code>Finite</code>, then <code>Continuous</code> for any <code>Count</code> or <code>Integer</code> scitypes/types</td></tr><tr><td style="text-align: left"><code>:string_to_multiclass</code></td><td style="text-align: left"><code>Multiclass</code> for any string-like column</td></tr></table><p>Autotype can be used in conjunction with <code>coerce</code>:</p><pre><code class="language-none">X_coerced = coerce(X, autotype(X))</code></pre><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>By default it only applies the <code>:few_to_many</code> rule</p><pre><code class="language-julia">n = 50
X = (a = rand(&quot;abc&quot;, n),         # 3 values, not number        --&gt; Multiclass
     b = rand([1,2,3,4], n),     # 4 values, number            --&gt; OrderedFactor
     c = rand([true,false], n),  # 2 values, number but only 2 --&gt; Multiclass
     d = randn(n),               # many values                 --&gt; unchanged
     e = rand(collect(1:n), n))  # many values                 --&gt; unchanged
autotype(X, only_changes=true)</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s14} where #s14&lt;:Union{Missing, Found}} with 3 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :c =&gt; Multiclass</code></pre><p>For example, we could first apply the <code>:discrete_to_continuous</code> rule, followed by <code>:few_to_finite</code> rule. The first rule will apply to <code>b</code> and <code>e</code> but the subsequent application of the second rule will mean we will get the same result apart for <code>e</code> (which will be <code>Continuous</code>)</p><pre><code class="language-julia">autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s14} where #s14&lt;:Union{Missing, Found}} with 4 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :e =&gt; Continuous
  :c =&gt; Multiclass</code></pre><p>One should check and possibly modify the returned dictionary before passing to <code>coerce</code>.</p><footer><hr/></footer></article></body></html>
