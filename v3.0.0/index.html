<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ScientificTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ScientificTypes.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Summary-of-the-default-convention"><span>Summary of the default convention</span></a></li><li><a class="tocitem" href="#Notes"><span>Notes</span></a></li><li><a class="tocitem" href="#Type-coercion-for-tabular-data"><span>Type coercion for tabular data</span></a></li><li><a class="tocitem" href="#Type-coercion-for-image-data"><span>Type coercion for image data</span></a></li><li><a class="tocitem" href="#Detailed-usage-examples"><span>Detailed usage examples</span></a></li><li><a class="tocitem" href="#Automatic-type-conversion"><span>Automatic type conversion</span></a></li><li><a class="tocitem" href="#API-reference"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ScientificTypes.jl"><a class="docs-heading-anchor" href="#ScientificTypes.jl">ScientificTypes.jl</a><a id="ScientificTypes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ScientificTypes.jl" title="Permalink"></a></h1><p>This package makes a distinction between <strong>machine type</strong> and <strong>scientific type</strong> of a Julia object:</p><ul><li><p>The <em>machine type</em> refers to the Julia type being used to represent the object (for instance, <code>Float64</code>).</p></li><li><p>The <em>scientific type</em> is one of the types defined in <a href="https://github.com/alan-turing-institute/ScientificTypesBase.jl">ScientificTypesBase.jl</a> reflecting how the object should be <em>interpreted</em> (for instance, <code>Continuous</code> or <code>Multiclass</code>).</p></li></ul><p>A <em>scientific type convention</em> is an assignment of a scientific type to every Julia object, articulated by overloading the <code>scitype</code> method.  The <code>DefaultConvention</code> convention is the convention used in various Julia ecosystems.</p><p>This package additionally defines tools for type coercion (the <code>coerce</code> method) and scientific type &quot;guessing&quot; (the <code>autotype</code> method).</p><p>Developers interested in implementing a different convention will instead import <a href="https://github.com/alan-turing-institute/ScientificTypesBase.jl">Scientific TypesBase.jl</a>, following the documentation there, possibly using this repo as a template.</p><h2 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h2><p>The supported scientific types have the following hierarchy:</p><pre><code class="language-none">Finite{N}
├─ Multiclass{N}
└─ OrderedFactor{N}

Infinite
├─ Continuous
└─ Count

Image{W,H}
├─ ColorImage{W,H}
└─ GrayImage{W,H}

ScientificTimeType
├─ ScientificDate
├─ ScientificTime
└─ ScientificDateTime

Sampleable{Ω}
└─ Density{Ω}

Annotated{S}

AnnotationFor{S}

Multiset{S}

Table{K}

Textual

ManifoldPoint{MT}

Unknown</code></pre><p>Additionally, we regard the Julia native types <code>Missing</code> and <code>Nothing</code> as scientific types as well.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>This documentation focuses on properties of the <code>scitype</code> method specific to the default convention. The <code>scitype</code> method satisfies certain universal properties, with respect to its operation on tuples, arrays and tables, set out in the ScientificTypes <a href="https://github.com/JuliaAI/ScientificTypesBase.jl#2-the-scitype-and-scitype-methods">readme</a>, but only implicitly described here.</p><p>To get the scientific type of a Julia object defined by the default convention, call <code>scitype</code>:</p><pre><code class="language-julia-repl">julia&gt; using ScientificTypes

julia&gt; scitype(3.14)
Continuous</code></pre><p>For a vector, you can use <code>scitype</code> or <code>elscitype</code> (which will give you a scitype corresponding to the elements):</p><pre><code class="language-julia-repl">julia&gt; scitype([1,2,3,missing])
AbstractVector{Union{Missing, Count}} (alias for AbstractArray{Union{Missing, Count}, 1})</code></pre><pre><code class="language-julia-repl">julia&gt; elscitype([1,2,3,missing])
Union{Missing, Count}</code></pre><p>Occasionally, you may want to find the union of all scitypes of elements of an arbitrary iterable, which you can do with <code>scitype_union</code>:</p><pre><code class="language-julia-repl">julia&gt; scitype_union((ifelse(isodd(i), i, missing) for i in 1:5))
Union{Missing, Count}</code></pre><p>Note calling <code>scitype_union</code> on a large array, for example, is typically much slower than calling <code>scitype</code> or <code>elscitype</code>.</p><h2 id="Summary-of-the-default-convention"><a class="docs-heading-anchor" href="#Summary-of-the-default-convention">Summary of the default convention</a><a id="Summary-of-the-default-convention-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-the-default-convention" title="Permalink"></a></h2><p>The table below summarizes the default convention for representing scientific types:</p><table><tr><th style="text-align: left">Type <code>T</code></th><th style="text-align: left"><code>scitype(x)</code> for <code>x::T</code></th><th style="text-align: left">package/module required</th></tr><tr><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Nothing</code></td><td style="text-align: left"><code>Nothing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractFloat</code></td><td style="text-align: left"><code>Continuous</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>Count</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>String</code></td><td style="text-align: left"><code>Textual</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays.jl</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays.jl</td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays.jl</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays.jl</td></tr><tr><td style="text-align: left"><code>Date</code></td><td style="text-align: left"><code>ScientificDate</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>Time</code></td><td style="text-align: left"><code>ScientificTime</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>DateTime</code></td><td style="text-align: left"><code>ScientificDateTime</code></td><td style="text-align: left">Dates</td></tr><tr><td style="text-align: left"><code>Distributions.Sampleable{F,S}</code></td><td style="text-align: left"><code>Sampleable{Ω}</code> where <code>Ω</code> is scitype of sample space, according to <code>{F,S}</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Distributions.Distributions{F,S}</code></td><td style="text-align: left"><code>Density{Ω}</code> where <code>Ω</code> is scitype of sample space, according to <code>{F,S}</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractArray{&lt;:Gray,2}</code></td><td style="text-align: left"><code>GrayImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes.jl</td></tr><tr><td style="text-align: left"><code>AbstractArrray{&lt;:AbstractRGB,2}</code></td><td style="text-align: left"><code>ColorImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes.jl</td></tr><tr><td style="text-align: left"><code>PersistenceDiagram</code></td><td style="text-align: left"><code>PersistenceDiagram</code></td><td style="text-align: left">PersistenceDiagramsBase</td></tr><tr><td style="text-align: left">any table type <code>T</code> supported by Tables.jl</td><td style="text-align: left"><code>Table{K}</code> where <code>K=Union{column_scitypes...}</code></td><td style="text-align: left">Tables.jl</td></tr><tr><td style="text-align: left">† <code>CorpusLoaders.TaggedWord</code></td><td style="text-align: left"><code>Annotated{Textual}</code></td><td style="text-align: left">CorpusLoaders.jl</td></tr><tr><td style="text-align: left">† <code>CorpusLoaders.Document{AbstractVector{Q}}</code></td><td style="text-align: left"><code>Annotated{AbstractVector{Scitype(Q)}}</code></td><td style="text-align: left">CorpusLoaders.jl</td></tr><tr><td style="text-align: left">† <code>AbstractDict{&lt;:AbstractString,&lt;:Integer}</code></td><td style="text-align: left"><code>Multiset{Textual}</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left">† <code>AbstractDict{&lt;:TaggedWord,&lt;:Integer}</code></td><td style="text-align: left"><code>Multiset{Annotated{Textual}}</code></td><td style="text-align: left">CorpusLoaders.jl</td></tr></table><p>† <em>Experimental</em> and subject to change in new minor or patch release</p><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><h2 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h2><ul><li>We regard the built-in Julia types <code>Missing</code> and <code>Nothing</code> as scientific types.</li><li><code>Finite{N}</code>, <code>Multiclass{N}</code> and <code>OrderedFactor{N}</code> are all parameterized by the number of levels <code>N</code>. We export the alias <code>Binary = Finite{2}</code>.</li><li><code>Image{W,H}</code>, <code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parameterized by the image width and height dimensions, <code>(W, H)</code>.</li><li><code>Sampleable{K}</code> andb</li></ul><p><code>Density{K} &lt;: Sampleable{K}</code> are parameterized by the sample space scitype.</p><ul><li>On objects for which the default convention has nothing to say, the <code>scitype</code> function returns <code>Unknown</code>.</li></ul><h3 id="Special-note-on-binary-data"><a class="docs-heading-anchor" href="#Special-note-on-binary-data">Special note on binary data</a><a id="Special-note-on-binary-data-1"></a><a class="docs-heading-anchor-permalink" href="#Special-note-on-binary-data" title="Permalink"></a></h3><p>ScientificTypes does not define a separate &quot;binary&quot; scientific type. Rather, when binary data has an intrinsic &quot;true&quot; class (for example pass/fail in a product test), then it should be assigned an <code>OrderedFactor{2}</code> scitype, while data with no such class (e.g., gender) should be assigned a <code>Multiclass{2}</code> scitype. In the <code>OrderedFactor{2}</code> case we adopt the convention that the &quot;true&quot; class come <em>after</em> the &quot;false&quot; class in the ordering (corresponding to the usual assignment &quot;false=0&quot; and &quot;true=1&quot;). Of course, <code>Finite{2}</code> covers both cases of binary data.</p><h2 id="Type-coercion-for-tabular-data"><a class="docs-heading-anchor" href="#Type-coercion-for-tabular-data">Type coercion for tabular data</a><a id="Type-coercion-for-tabular-data-1"></a><a class="docs-heading-anchor-permalink" href="#Type-coercion-for-tabular-data" title="Permalink"></a></h2><p>A common two-step work-flow is:</p><ol><li><p>Inspect the <code>schema</code> of some table, and the column <code>scitypes</code> in particular.</p></li><li><p>Provide pairs of column names and scitypes (or a dictionary) that change the column machine types to reflect the desired scientific interpretation (scitype).</p></li></ol><pre><code class="language-julia">using DataFrames, Tables
X = DataFrame(
	 name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
	 height=[152, missing, 148, 163],
	 rating=[1, 5, 2, 1])
schema(X)</code></pre><pre class="documenter-example-output">┌────────┬───────────────────────┬───────────────────────┐
│ names  │ scitypes              │ types                 │
├────────┼───────────────────────┼───────────────────────┤
│ name   │ Textual               │ String                │
│ height │ Union{Missing, Count} │ Union{Missing, Int64} │
│ rating │ Count                 │ Int64                 │
└────────┴───────────────────────┴───────────────────────┘
</pre><p>In some further analysis of the data in <code>X</code>, a more likely interpretation is that <code>:name</code> is <code>Multiclass</code>, the <code>:height</code> is <code>Continuous</code>, and the <code>:rating</code> an <code>OrderedFactor</code>. Correcting the types with <code>coerce</code>:</p><pre><code class="language-julia">Xfixed = coerce(X, :name=&gt;Multiclass,
                   :height=&gt;Continuous,
                   :rating=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre class="documenter-example-output">(Multiclass{4}, Union{Missing, Continuous}, OrderedFactor{3})</pre><p>Note that because missing values were encountered in <code>height</code>, an &quot;imperfect&quot; type coercion to <code>Union{Missing,Continuous}</code> has been performed, and a warning issued.  To avoid the warning, coerce to <code>Union{Missing,Continuous}</code> instead.</p><p>&quot;Global&quot; replacements based on existing scientific types are also possible, and can be mixed with the name-based replacements:</p><pre><code class="language-julia">X  = (x = [1, 2, 3],
      y = [&#39;A&#39;, &#39;B&#39;, &#39;A&#39;],
      z = [10, 20, 30])
Xfixed = coerce(X, Count=&gt;Continuous, :y=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre class="documenter-example-output">(Continuous, OrderedFactor{2}, Continuous)</pre><p>Finally there is a <code>coerce!</code> method that does in-place coercion provided the data structure supports it.</p><h2 id="Type-coercion-for-image-data"><a class="docs-heading-anchor" href="#Type-coercion-for-image-data">Type coercion for image data</a><a id="Type-coercion-for-image-data-1"></a><a class="docs-heading-anchor-permalink" href="#Type-coercion-for-image-data" title="Permalink"></a></h2><p>To have a scientific type of <code>Image</code> a julia object must be a two-dimensional array whose element type is subtype of <code>Gray</code> or <code>AbstractRGB</code> (color types from the <a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a> package). And models typically expect <em>collections</em> of images to be vectors of such two-dimensional arrays. Implementations of <code>coerce</code> allow the conversion of some common image formats into one of these. The eltype in these other formats can be any subtype of <code>Real</code>, which includes the <code>FixedPoint</code> type from the <a href="https://github.com/JuliaMath/FixedPointNumbers.jl">FixedPointNumbers.jl</a> package.</p><h3 id="Coercing-a-single-image"><a class="docs-heading-anchor" href="#Coercing-a-single-image">Coercing a single image</a><a id="Coercing-a-single-image-1"></a><a class="docs-heading-anchor-permalink" href="#Coercing-a-single-image" title="Permalink"></a></h3><p>Coercing a <strong>gray</strong> image, represented as a <code>Real</code> matrix (W x H format):</p><pre><code class="language-julia">img = rand(10, 10)
coerce(img, GrayImage) |&gt; scitype</code></pre><pre class="documenter-example-output">GrayImage{10, 10}</pre><p>Coercing a <strong>color</strong> image, represented as a <code>Real</code> 3-D array (W x H x C format):</p><pre><code class="language-julia">img = rand(10, 10, 3)
coerce(img, ColorImage) |&gt; scitype</code></pre><pre class="documenter-example-output">ColorImage{10, 10}</pre><h3 id="Coercing-collections-of-images"><a class="docs-heading-anchor" href="#Coercing-collections-of-images">Coercing collections of images</a><a id="Coercing-collections-of-images-1"></a><a class="docs-heading-anchor-permalink" href="#Coercing-collections-of-images" title="Permalink"></a></h3><p>Coercing a <strong>collection</strong> of <strong>gray</strong> images, represented as a <code>Real</code> 3-D array (W x H x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 3)
coerce(imgs, GrayImage) |&gt; scitype</code></pre><pre class="documenter-example-output">AbstractVector{GrayImage{10, 10}} (alias for AbstractArray{GrayImage{10, 10}, 1})</pre><p>Coercing a <strong>collection</strong> of <strong>gray</strong> images, represented as a <code>Real</code> 4-D array (W x H x {1} x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 1, 3)
coerce(imgs, GrayImage) |&gt; scitype</code></pre><pre class="documenter-example-output">AbstractVector{GrayImage{10, 10}} (alias for AbstractArray{GrayImage{10, 10}, 1})</pre><p>Coercing a <strong>collection</strong> of <strong>color</strong> images, represented as a <code>Real</code> 4-D array (W x H x C x N format):</p><pre><code class="language-julia">imgs = rand(10, 10, 3, 5)
coerce(imgs, ColorImage) |&gt; scitype</code></pre><pre class="documenter-example-output">AbstractVector{ColorImage{10, 10}} (alias for AbstractArray{ColorImage{10, 10}, 1})</pre><h2 id="Detailed-usage-examples"><a class="docs-heading-anchor" href="#Detailed-usage-examples">Detailed usage examples</a><a id="Detailed-usage-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-usage-examples" title="Permalink"></a></h2><h3 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h3><pre><code class="language-julia">using CategoricalArrays
scitype((2.718, 42))</code></pre><pre class="documenter-example-output">Tuple{Continuous, Count}</pre><p>In the default convention, to construct arrays with categorical scientific element type one needs to use <code>CategorialArrays</code>:</p><pre><code class="language-julia">v = categorical([&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, missing, &#39;b&#39;], ordered=true)
scitype(v[1])</code></pre><pre class="documenter-example-output">OrderedFactor{3}</pre><pre><code class="language-julia">elscitype(v)</code></pre><pre class="documenter-example-output">Union{Missing, OrderedFactor{3}}</pre><p>Coercing to <code>Multiclass</code>:</p><pre><code class="language-julia">w = coerce(v, Union{Missing,Multiclass})
elscitype(w)</code></pre><pre class="documenter-example-output">Union{Missing, Multiclass{3}}</pre><h3 id="Working-with-tables"><a class="docs-heading-anchor" href="#Working-with-tables">Working with tables</a><a id="Working-with-tables-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-tables" title="Permalink"></a></h3><p>While <code>schema</code> is convenient for inspecting the column scitypes of a table, there is also a scitype for the tables themselves:</p><pre><code class="language-julia">data = (x1=rand(10), x2=rand(10))
schema(data)</code></pre><pre class="documenter-example-output">┌───────┬────────────┬─────────┐
│ names │ scitypes   │ types   │
├───────┼────────────┼─────────┤
│ x1    │ Continuous │ Float64 │
│ x2    │ Continuous │ Float64 │
└───────┴────────────┴─────────┘
</pre><pre><code class="language-julia">scitype(data)</code></pre><pre class="documenter-example-output">Table{AbstractVector{Continuous}}</pre><p>Similarly, any table implementing the Tables interface has scitype <code>Table{K}</code>, where <code>K</code> is the union of the scitypes of its columns.</p><p>Table scitypes are useful for dispatch and type checks, as shown here, with the help of a constructor for <code>Table</code> scitypes provided by <a href="https://github.com/alan-turing-institute/ScientificTypes.jl">Scientific Types.jl</a>:</p><pre><code class="language-julia">Table(Continuous, Count)</code></pre><pre><code class="language-julia">Table{&lt;:Union{AbstractArray{&lt;:Continuous},AbstractArray{&lt;:Count}}}</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Continuous)</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">scitype(data) &lt;: Table(Infinite)</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])
data = coerce(data, :z=&gt;OrderedFactor)
scitype(data) &lt;: Table(Continuous,Count,OrderedFactor)</code></pre><pre class="documenter-example-output">true</pre><p>Note that <code>Table(Continuous,Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p><h3 id="Tuples-and-arrays"><a class="docs-heading-anchor" href="#Tuples-and-arrays">Tuples and arrays</a><a id="Tuples-and-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Tuples-and-arrays" title="Permalink"></a></h3><p>The behavior of <code>scitype</code> on tuples is as you would expect:</p><pre><code class="language-julia">scitype((1, 4.5))</code></pre><pre class="documenter-example-output">Tuple{Count, Continuous}</pre><p>For performance reasons, the behavior of <code>scitype</code> on arrays has some wrinkles, in the case of missing values:</p><p><strong>The scitype of an array.</strong> The scitype of an <code>AbstractArray</code>, <code>A</code>, is always<code>AbstractArray{U}</code> where <code>U</code> is the union of the scitypes of the elements of <code>A</code>, with one exception: If <code>typeof(A) &lt;: AbstractArray{Union{Missing,T}}</code> for some <code>T</code> different from <code>Any</code>, then the scitype of <code>A</code> is <code>AbstractArray{Union{Missing, U}}</code>, where <code>U</code> is the union over all non-missing elements, <strong>even if <code>A</code> has no missing elements.</strong></p><pre><code class="language-julia">julia&gt; v = [1.3, 4.5, missing]
julia&gt; scitype(v)
AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">julia&gt; scitype(v[1:2])
AbstractArray{Union{Missing, Continuous},1}</code></pre><h2 id="Automatic-type-conversion"><a class="docs-heading-anchor" href="#Automatic-type-conversion">Automatic type conversion</a><a id="Automatic-type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-type-conversion" title="Permalink"></a></h2><p>The <code>autotype</code> function allows to use specific rules in order to guess appropriate scientific types for <em>tabular</em> data. Such rules would typically be more constraining than the ones implied by the active convention. When <code>autotype</code> is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as &quot;fallback&quot;.</p><p>The function is called as:</p><pre><code class="language-julia">autotype(X)</code></pre><p>If the keyword <code>only_changes</code> is passed set to <code>true</code>, then only the column names for which the suggested type is different from that provided by the convention are returned.</p><pre><code class="language-julia">autotype(X; only_changes=true)</code></pre><p>To specify which rules are to be applied, use the <code>rules</code> keyword  and specify a tuple of symbols referring to specific rules; the default rule is <code>:few_to_finite</code> which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate <code>Finite</code> type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.</p><pre><code class="language-julia">autotype(X; rules=(:few_to_finite,))</code></pre><p>Finally, you can also use the following shorthands:</p><pre><code class="language-julia">autotype(X, :few_to_finite)
autotype(X, (:few_to_finite, :discrete_to_continuous))</code></pre><h3 id="Available-rules"><a class="docs-heading-anchor" href="#Available-rules">Available rules</a><a id="Available-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Available-rules" title="Permalink"></a></h3><table><tr><th style="text-align: left">Rule symbol</th><th style="text-align: left">scitype suggestion</th></tr><tr><td style="text-align: left"><code>:few_to_finite</code></td><td style="text-align: left">an appropriate <code>Finite</code> subtype for columns with few distinct values</td></tr><tr><td style="text-align: left"><code>:discrete_to_continuous</code></td><td style="text-align: left">if not <code>Finite</code>, then <code>Continuous</code> for any <code>Count</code> or <code>Integer</code> scitypes/types</td></tr><tr><td style="text-align: left"><code>:string_to_multiclass</code></td><td style="text-align: left"><code>Multiclass</code> for any string-like column</td></tr></table><p>Autotype can be used in conjunction with <code>coerce</code>:</p><pre><code class="language-none">X_coerced = coerce(X, autotype(X))</code></pre><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>By default it only applies the <code>:few_to_finite</code> rule</p><pre><code class="language-julia">n = 50
X = (a = rand(&quot;abc&quot;, n),         # 3 values, not number        --&gt; Multiclass
     b = rand([1,2,3,4], n),     # 4 values, number            --&gt; OrderedFactor
     c = rand([true,false], n),  # 2 values, number but only 2 --&gt; Multiclass
     d = randn(n),               # many values                 --&gt; unchanged
     e = rand(collect(1:n), n))  # many values                 --&gt; unchanged
autotype(X, only_changes=true)</code></pre><pre class="documenter-example-output">Dict{Symbol, Type} with 3 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :c =&gt; OrderedFactor</pre><p>For example, we could first apply the <code>:discrete_to_continuous</code> rule, followed by <code>:few_to_finite</code> rule. The first rule will apply to <code>b</code> and <code>e</code> but the subsequent application of the second rule will mean we will get the same result apart for <code>e</code> (which will be <code>Continuous</code>)</p><pre><code class="language-julia">autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))</code></pre><pre class="documenter-example-output">Dict{Symbol, Type} with 4 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :e =&gt; Continuous
  :c =&gt; OrderedFactor</pre><p>One should check and possibly modify the returned dictionary before passing to <code>coerce</code>.</p><h2 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ScientificTypes.scitype" href="#ScientificTypes.scitype"><code>ScientificTypes.scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The scientific type (interpretation) of <code>X</code>, as distinct from its machine type, as specified by the active convention.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; scitype(3.14)
Continuous

julia&gt; scitype([1, 2, missing])
AbstractVector{Union{Missing, Count}} 

julia&gt; scitype((5, &quot;beige&quot;))
Tuple{Count, Textual}

using CategoricalArrays
X = (gender = categorical([&#39;M&#39;, &#39;M&#39;, &#39;F&#39;, &#39;M&#39;, &#39;F&#39;]),
     ndevices = [1, 3, 2, 3, 2])
julia&gt; scitype(X)
Table{Union{AbstractVector{Count}, AbstractVector{Multiclass{2}}}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/17bab2c5efb6d8bbb41aaa71cc2ebe4aef3d88dc/src/convention/scitype.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypes.coerce" href="#ScientificTypes.coerce"><code>ScientificTypes.coerce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coerce(A, S)</code></pre><p>Return new version of the array <code>A</code> whose scientific element type is <code>S</code>.</p><pre><code class="language-none">julia&gt; v = coerce([3, 7, 5], Continuous)
3-element Vector{Float64}:
 3.0
 7.0
 5.0

julia&gt; scitype(v)
AbstractVector{Continuous}
</code></pre><pre><code class="language-none">coerce(X, specs...; tight=false, verbosity=1)</code></pre><p>Given a table <code>X</code>, return a copy of <code>X</code>, ensuring that the element scitypes of the columns match the new specification, <code>specs</code>. There are three valid specifications:</p><p>(i) one or more <code>column_name=&gt;Scitype</code> pairs:</p><pre><code class="language-none">coerce(X, col1=&gt;Scitype1, col2=&gt;Scitype2, ... ; verbosity=1)</code></pre><p>(ii) one or more <code>OldScitype=&gt;NewScitype</code> pairs (<code>OldScitype</code> covering both the <code>OldScitype</code> and <code>Union{Missing,OldScitype}</code> cases):</p><pre><code class="language-none">coerce(X, OldScitype1=&gt;NewScitype1, OldScitype2=&gt;NewScitype2, ... ; verbosity=1)</code></pre><p>(iii) a dictionary of scientific types keyed on column names:</p><pre><code class="language-none">coerce(X, d::AbstractDict{&lt;:ColKey, &lt;:Type}; verbosity=1)</code></pre><p>where <code>ColKey = Union{Symbol,AbstractString}</code>.</p><p><strong>Examples</strong></p><p>Specifying  <code>column_name=&gt;Scitype</code> pairs:</p><pre><code class="language-none">using CategoricalArrays, DataFrames, Tables
X = DataFrame(name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
              height=[152, missing, 148, 163],
              rating=[1, 5, 2, 1])
Xc = coerce(X, :name=&gt;Multiclass, :height=&gt;Continuous, :rating=&gt;OrderedFactor)
schema(Xc).scitypes # (Multiclass, Continuous, OrderedFactor)</code></pre><p>Specifying <code>OldScitype=&gt;NewScitype</code> pairs:</p><pre><code class="language-none">X  = (x = [1, 2, 3],
      y = rand(3),
      z = [10, 20, 30])
Xc = coerce(X, Count=&gt;Continuous)
schema(Xfixed).scitypes # (Continuous, Continuous, Continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/17bab2c5efb6d8bbb41aaa71cc2ebe4aef3d88dc/src/coerce.jl#L3-L62">source</a></section><section><div><pre><code class="language-none">coerce(image::AbstractArray{&lt;:Real, N}, I)</code></pre><p>Given a an array called <code>image</code> representing one or more images, return a transformed version of the data so as to enforce an appropriate scientific interpretation <code>I</code>:</p><table><tr><th style="text-align: right">single or collection ?</th><th style="text-align: right">N</th><th style="text-align: right">I</th><th style="text-align: right"><code>scitype</code> of result</th></tr><tr><td style="text-align: right">single</td><td style="text-align: right">2</td><td style="text-align: right"><code>GrayImage</code></td><td style="text-align: right"><code>GrayImage{W,H}</code></td></tr><tr><td style="text-align: right">single</td><td style="text-align: right">3</td><td style="text-align: right"><code>ColorImage</code></td><td style="text-align: right"><code>ColorImage{W,H}</code></td></tr><tr><td style="text-align: right">collection</td><td style="text-align: right">3</td><td style="text-align: right"><code>GrayImage</code></td><td style="text-align: right"><code>AbstractVector{&lt;:GrayImage}</code></td></tr><tr><td style="text-align: right">collection</td><td style="text-align: right">4 (W x H x {1} x C)</td><td style="text-align: right"><code>GrayImage</code></td><td style="text-align: right"><code>AbstractVector{&lt;:GrayImage}</code></td></tr><tr><td style="text-align: right">collection</td><td style="text-align: right">4</td><td style="text-align: right"><code>ColorImage</code></td><td style="text-align: right"><code>AbstractVector{&lt;:ColorImage}</code></td></tr></table><pre><code class="language-none">imgs = rand(10, 10, 3, 5)
v = coerce(imgs, ColorImage)

julia&gt; typeof(v)
Vector{Matrix{ColorTypes.RGB{Float64}}}

julia&gt; scitype(v)
AbstractVector{ColorImage{10, 10}}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/17bab2c5efb6d8bbb41aaa71cc2ebe4aef3d88dc/src/convention/coerce.jl#L227-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ScientificTypes.autotype" href="#ScientificTypes.autotype"><code>ScientificTypes.autotype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">autotype(X; kw...)</code></pre><p>Return a dictionary of suggested scitypes for each column of <code>X</code>, a table or an array based on rules</p><p><strong>Kwargs</strong></p><ul><li><code>only_changes=true</code>:       if true, return only a dictionary of the names for                             which applying autotype differs from just using                             the ambient convention. When coercing with                             autotype, <code>only_changes</code> should be true.</li><li><code>rules=(:few_to_finite,)</code>: the set of rules to apply.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/ScientificTypes.jl/blob/17bab2c5efb6d8bbb41aaa71cc2ebe4aef3d88dc/src/autotype.jl#L1-L14">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 December 2021 02:09">Thursday 23 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
