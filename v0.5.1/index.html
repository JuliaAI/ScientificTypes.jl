<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ScientificTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ScientificTypes.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Features-1"><span>Features</span></a></li><li><a class="tocitem" href="#Getting-started-1"><span>Getting started</span></a></li><li><a class="tocitem" href="#Notes-1"><span>Notes</span></a></li><li><a class="tocitem" href="#Special-note-on-binary-data-1"><span>Special note on binary data</span></a></li><li><a class="tocitem" href="#Detailed-usage-examples-1"><span>Detailed usage examples</span></a></li><li><a class="tocitem" href="#The-MLJ-convention-1"><span>The MLJ convention</span></a></li><li><a class="tocitem" href="#Automatic-type-conversion-for-tabular-data-1"><span>Automatic type conversion for tabular data</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/ScientificTypes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ScientificTypes.jl-1"><a class="docs-heading-anchor" href="#ScientificTypes.jl-1">ScientificTypes.jl</a><a class="docs-heading-anchor-permalink" href="#ScientificTypes.jl-1" title="Permalink"></a></h1><p>A light-weight Julia interface for implementing conventions about the scientific interpretation of data, and for performing type coercions enforcing those conventions.</p><p>The package makes the distinction between between <strong>machine type</strong> and <strong>scientific type</strong>:</p><ul><li>the <em>machine type</em> is a Julia type the data is currently encoded as (for instance: <code>Float64</code>)</li><li>the <em>scientific type</em> is a type defined by this package which encapsulates how the data should be <em>interpreted</em> in the rest of the code (for instance: <code>Continuous</code> or <code>Multiclass</code>)</li></ul><p>As a motivating example, the data might contain a column corresponding to a <em>number of transactions</em>, the machine type in that case could be an <code>Int</code> whereas the scientific type would be a <code>Count</code>.</p><p>The usefulness of this machinery becomes evident when the machine type does not directly connect with a scientific type; taking the previous example, the data could have been encoded as a <code>Float64</code> whereas the meaning should still be a <code>Count</code>.</p><h2 id="Features-1"><a class="docs-heading-anchor" href="#Features-1">Features</a><a class="docs-heading-anchor-permalink" href="#Features-1" title="Permalink"></a></h2><p>The package  <code>ScientificTypes</code> provides:</p><ul><li>A hierarchy of new Julia types representing scientific data types for use in method dispatch (eg, for trait values). Instances of the types play no role:</li></ul><pre><code class="language-none">Found
├─ Known
│  ├─ Finite
│  │  ├─ Multiclass
│  │  └─ OrderedFactor
│  ├─ Infinite
│  │  ├─ Continuous
│  │  └─ Count
│  ├─ Image
│  │  ├─ ColorImage
│  │  └─ GrayImage
|  ├─ Textual
│  └─ Table
└─ Unknown</code></pre><ul><li>A single method <code>scitype</code> for articulating a convention about what scientific type each Julia object can represent. For example, one might declare <code>scitype(::AbstractFloat) = Continuous</code>.</li><li>A default convention called <em>MLJ</em>, based on dependencies <code>CategoricalArrays</code>, <code>ColorTypes</code>, and <code>Tables</code>, which includes a convenience method <code>coerce</code> for performing scientific type coercion on <code>AbstractVectors</code> and columns of tabular data (any table implementing the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface).</li><li>A <code>schema</code> method for tabular data, based on the optional Tables dependency, for inspecting the machine and scientific types of tabular data, in addition to column names and number of rows.</li></ul><h2 id="Getting-started-1"><a class="docs-heading-anchor" href="#Getting-started-1">Getting started</a><a class="docs-heading-anchor-permalink" href="#Getting-started-1" title="Permalink"></a></h2><p>The package is registered and can be installed via the package manager with <code>add ScientificTypes</code>.</p><p>To get the scientific type of a Julia object according to the convention in use, call <code>scitype</code>:</p><pre><code class="language-julia">scitype(3.14)</code></pre><pre><code class="language-none">Continuous</code></pre><p>For a vector, you can use <code>scitype</code> or <code>scitype_union</code> (which will give you a scitype corresponding to the elements):</p><pre><code class="language-julia">scitype([1,2,3,missing])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Count},1}</code></pre><pre><code class="language-julia">scitype_union([1,2,3,missing])</code></pre><pre><code class="language-none">Union{Missing, Count}</code></pre><h3 id="Type-coercion-work-flow-for-tabular-data-1"><a class="docs-heading-anchor" href="#Type-coercion-work-flow-for-tabular-data-1">Type coercion work-flow for tabular data</a><a class="docs-heading-anchor-permalink" href="#Type-coercion-work-flow-for-tabular-data-1" title="Permalink"></a></h3><p>The standard workflow involves the following two steps:</p><ol><li>inspect the <code>schema</code> of the data and the <code>scitypes</code> in particular</li><li>provide pairs or a dictionary with column names and scitypes for any changes you may want and coerce the data to those scitypes</li></ol><pre><code class="language-julia">using DataFrames, Tables
X = DataFrame(
     name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
     height=[152, missing, 148, 163],
     rating=[1, 5, 2, 1])
schema(X)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬───────────────────────┬───────────────────────┐
│ _.names │ _.types               │ _.scitypes            │
├─────────┼───────────────────────┼───────────────────────┤
│ name    │ String                │ Textual               │
│ height  │ Union{Missing, Int64} │ Union{Missing, Count} │
│ rating  │ Int64                 │ Count                 │
└─────────┴───────────────────────┴───────────────────────┘
_.nrows = 4
</code></pre><p>inspecting the scitypes:</p><pre><code class="language-julia">schema(X).scitypes</code></pre><pre><code class="language-none">(Textual, Union{Missing, Count}, Count)</code></pre><p>but in this case you may want to map the names to <code>Multiclass</code>, the height to <code>Continuous</code> and the ratings to <code>OrderedFactor</code>; to do so:</p><pre><code class="language-julia">Xfixed = coerce(X, :name=&gt;Multiclass,
                   :height=&gt;Continuous,
                   :rating=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Multiclass{4}, Union{Missing, Continuous}, OrderedFactor{3})</code></pre><p>Note that, as it encountered missing values in <code>height</code> it coerced the type to <code>Union{Missing,Continuous}</code>.</p><p>One can also make a replacement based on existing scientific type, instead of feature name:</p><pre><code class="language-julia">X  = (x = [1, 2, 3],
      y = rand(3),
      z = [10, 20, 30])
Xfixed = coerce(X, Count=&gt;Continuous)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Continuous, Continuous, Continuous)</code></pre><p>Finally there is a <code>coerce!</code> method that does in-place coercion provided the data structure allows it (at the moment only <code>DataFrames.DataFrame</code> is supported).</p><h2 id="Notes-1"><a class="docs-heading-anchor" href="#Notes-1">Notes</a><a class="docs-heading-anchor-permalink" href="#Notes-1" title="Permalink"></a></h2><ul><li>We regard the built-in Julia type <code>Missing</code> as a scientific type. The new scientific types introduced in the current package are rooted in the abstract type <code>Found</code> (see tree above) and you export the alias <code>Scientific = Union{Missing, Found}</code>.</li><li><code>Finite{N}</code>, <code>Multiclass{N}</code> and <code>OrderedFactor{N}</code> are all parametrised by the number of levels <code>N</code>. We export the alias <code>Binary = Finite{2}</code>.</li><li><code>Image{W,H}</code>, <code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parametrised by the image width and height dimensions, <code>(W, H)</code>.</li><li>The function <code>scitype</code> has the fallback value <code>Unknown</code>.</li><li>Since Tables is an optional dependency, the <code>scitype</code> of a <a href="https://github.com/JuliaData/Tables.jl"><code>Tables.jl</code></a> supported table is <code>Unknown</code> unless Tables has been imported.</li><li>Developers can define their own conventions using the code in <code>src/conventions/mlj/</code> as a template. The active convention is controlled by the value of <code>ScientificTypes.CONVENTION[1]</code>.</li></ul><h2 id="Special-note-on-binary-data-1"><a class="docs-heading-anchor" href="#Special-note-on-binary-data-1">Special note on binary data</a><a class="docs-heading-anchor-permalink" href="#Special-note-on-binary-data-1" title="Permalink"></a></h2><p>ScientificTypes does not define a separate &quot;binary&quot; scientific type. Rather, when binary data has an intrinsic &quot;true&quot; class (for example pass/fail in a product test), then it should be assigned an <code>OrderedFactor{2}</code> scitype, while data with no such class (e.g., gender) should be assigned a <code>Multiclass{2}</code> scitype. In the former case we recommend that the &quot;true&quot; class come after &quot;false&quot; in the ordering (corresponding to the usual assignment &quot;false=0&quot; and &quot;true=1&quot;). Of course, <code>Finite{2}</code> covers both cases of binary data.</p><h2 id="Detailed-usage-examples-1"><a class="docs-heading-anchor" href="#Detailed-usage-examples-1">Detailed usage examples</a><a class="docs-heading-anchor-permalink" href="#Detailed-usage-examples-1" title="Permalink"></a></h2><pre><code class="language-">using ScientificTypes
# activate a convention
ScientificTypes.set_convention(MLJ) # redundant as it&#39;s the default

scitype((2.718, 42))</code></pre><p>Let&#39;s try with categorical valued objects:</p><pre><code class="language-julia">using CategoricalArrays
v = categorical([&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, missing, &#39;b&#39;], ordered=true)
scitype(v[1])</code></pre><pre><code class="language-none">OrderedFactor{3}</code></pre><p>and</p><pre><code class="language-julia">scitype_union(v)</code></pre><pre><code class="language-none">Union{Missing, OrderedFactor{3}}</code></pre><p>you could coerce this to <code>Multiclass</code>:</p><pre><code class="language-julia">w = coerce(v, Multiclass)
scitype_union(w)</code></pre><pre><code class="language-none">Union{Missing, Multiclass{3}}</code></pre><h3 id="Working-with-tables-1"><a class="docs-heading-anchor" href="#Working-with-tables-1">Working with tables</a><a class="docs-heading-anchor-permalink" href="#Working-with-tables-1" title="Permalink"></a></h3><pre><code class="language-julia">using Tables
data = (x1=rand(10), x2=rand(10), x3=collect(1:10))
scitype(data)</code></pre><pre><code class="language-none">Table{Union{AbstractArray{Continuous,1}, AbstractArray{Count,1}}}</code></pre><p>you can also use <code>schema</code>:</p><pre><code class="language-julia">schema(data)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬─────────┬────────────┐
│ _.names │ _.types │ _.scitypes │
├─────────┼─────────┼────────────┤
│ x1      │ Float64 │ Continuous │
│ x2      │ Float64 │ Continuous │
│ x3      │ Int64   │ Count      │
└─────────┴─────────┴────────────┘
_.nrows = 10
</code></pre><p>and use <code>&lt;:</code> for type checks:</p><pre><code class="language-julia">scitype(data) &lt;: Table(Continuous)</code></pre><pre><code class="language-none">false</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Infinite)</code></pre><pre><code class="language-none">true</code></pre><p>or specify multiple types directly:</p><pre><code class="language-julia">data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])
data = coerce(data, :z=&gt;OrderedFactor)
scitype(data) &lt;: Table(Continuous,Count,OrderedFactor)</code></pre><pre><code class="language-none">true</code></pre><h3 id="The-scientific-type-of-tuples,-arrays-and-tables-1"><a class="docs-heading-anchor" href="#The-scientific-type-of-tuples,-arrays-and-tables-1">The scientific type of tuples, arrays and tables</a><a class="docs-heading-anchor-permalink" href="#The-scientific-type-of-tuples,-arrays-and-tables-1" title="Permalink"></a></h3><p><strong>Important Definition 1</strong> Under any convention, the scitype of a tuple is a <code>Tuple</code> type parametrised by scientific types:</p><pre><code class="language-julia">scitype((1, 4.5))</code></pre><pre><code class="language-none">Tuple{Count,Continuous}</code></pre><p><strong>Important Definition 2</strong> The scitype of an <code>AbstractArray</code>, <code>A</code>, is always<code>AbstractArray{U}</code> where <code>U</code> is the union of the scitpyes of the elements of <code>A</code>, with one exception: If <code>typeof(A) &lt;: AbstractArray{Union{Missing,T}}</code> for some <code>T</code> different from <code>Any</code>, then the scitype of <code>A</code> is <code>AbstractArray{Union{Missing, U}}</code>, where <code>U</code> is the union over all non-missing elements, <strong>even if <code>A</code> has no missing elements</strong>.</p><p>This exception is made for performance reasons. If one wants to override it, one uses <code>scitype(A, tight=true)</code>.</p><pre><code class="language-julia">v = [1.3, 4.5, missing]
scitype(v)</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">scitype(v[1:2])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">scitype(v[1:2], tight=true)</code></pre><pre><code class="language-none">AbstractArray{Continuous,1}</code></pre><p><em>Performance note:</em> Computing type unions over large arrays is expensive and, depending on the convention&#39;s implementation and the array eltype, computing the scitype can be slow. In the <em>MLJ</em> convention this is mitigated with the help of the <code>ScientificTypes.Scitype</code> method, of which other conventions could make use. Do <code>?ScientificTypes.Scitype</code> for details. An eltype <code>Any</code> may lead to poor performances and you may want to consider replacing an array <code>A</code> with <code>broadcast(identity, A)</code> to collapse the eltype and speed up the computation.</p><p>Provided the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> package is loaded, any table implementing the Tables interface has a scitype encoding the scitypes of its columns:</p><pre><code class="language-julia">using CategoricalArrays, Tables
X = (x1=rand(10),
     x2=rand(10),
     x3=categorical(rand(&quot;abc&quot;, 10)),
     x4=categorical(rand(&quot;01&quot;, 10)))
schema(X)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬─────────────────────────────────────────────────┬───────────────┐
│ _.names │ _.types                                         │ _.scitypes    │
├─────────┼─────────────────────────────────────────────────┼───────────────┤
│ x1      │ Float64                                         │ Continuous    │
│ x2      │ Float64                                         │ Continuous    │
│ x3      │ CategoricalArrays.CategoricalValue{Char,UInt32} │ Multiclass{3} │
│ x4      │ CategoricalArrays.CategoricalValue{Char,UInt32} │ Multiclass{2} │
└─────────┴─────────────────────────────────────────────────┴───────────────┘
_.nrows = 10
</code></pre><p><strong>Important Definition 3</strong> Specifically, if <code>X</code> has columns <code>c1, ..., cn</code>, then</p><pre><code class="language-julia">scitype(X) == Table{Union{scitype(c1), ..., scitype(cn)}}</code></pre><p>With this definition, common type checks can be performed with tables. For instance, you could check that each column of <code>X</code> has an element scitype that is either <code>Continuous</code> or <code>Finite</code>:</p><pre><code class="language-julia">scitype(X) &lt;: Table{&lt;:Union{AbstractVector{&lt;:Continuous}, AbstractVector{&lt;:Finite}}}</code></pre><pre><code class="language-none">true</code></pre><p>A built-in <code>Table</code> constructor provides a shorthand for the right-hand side:</p><pre><code class="language-julia">scitype(X) &lt;: Table(Continuous, Finite)</code></pre><pre><code class="language-none">true</code></pre><p>Note that <code>Table(Continuous,Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p><h2 id="The-MLJ-convention-1"><a class="docs-heading-anchor" href="#The-MLJ-convention-1">The MLJ convention</a><a class="docs-heading-anchor-permalink" href="#The-MLJ-convention-1" title="Permalink"></a></h2><p>The table below summarises the <em>MLJ</em> convention for representing scientific types:</p><table><tr><th style="text-align: left">Type <code>T</code></th><th style="text-align: left"><code>scitype(x)</code> for <code>x::T</code></th><th style="text-align: left">package required</th></tr><tr><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractFloat</code></td><td style="text-align: left"><code>Continuous</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>Count</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>String</code></td><td style="text-align: left"><code>Textual</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>AbstractArray{&lt;:Gray,2}</code></td><td style="text-align: left"><code>GrayImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left"><code>AbstractArrray{&lt;:AbstractRGB,2}</code></td><td style="text-align: left"><code>ColorImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left">any table type <code>T</code> supported by Tables.jl</td><td style="text-align: left"><code>Table{K}</code> where <code>K=Union{column_scitypes...}</code></td><td style="text-align: left">Tables</td></tr></table><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><h2 id="Automatic-type-conversion-for-tabular-data-1"><a class="docs-heading-anchor" href="#Automatic-type-conversion-for-tabular-data-1">Automatic type conversion for tabular data</a><a class="docs-heading-anchor-permalink" href="#Automatic-type-conversion-for-tabular-data-1" title="Permalink"></a></h2><p>The <code>autotype</code> function allows to use specific rules in order to guess appropriate scientific types for the data. Such rules would typically be more constraining than the ones implied by the active convention. When <code>autotype</code> is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as &quot;fallback&quot;.</p><p>The function is called as:</p><pre><code class="language-julia">autotype(X)</code></pre><p>If the keyword <code>only_changes</code> is passed set to <code>true</code>, then only the column names for which the suggested type is different from that provided by the convention are returned.</p><pre><code class="language-julia">autotype(X; only_changes=true)</code></pre><p>To specify which rules are to be applied, use the <code>rules</code> keyword  and specify a tuple of symbols referring to specific rules; the default rule is <code>:few_to_finite</code> which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate <code>Finite</code> type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.</p><pre><code class="language-julia">autotype(X; rules=(:few_to_finite,))</code></pre><p>Finally, you can also use the following shorthands:</p><pre><code class="language-julia">autotype(X, :few_to_finite)
autotype(X, (:few_to_finite, :discrete_to_continuous))</code></pre><h3 id="Available-rules-1"><a class="docs-heading-anchor" href="#Available-rules-1">Available rules</a><a class="docs-heading-anchor-permalink" href="#Available-rules-1" title="Permalink"></a></h3><table><tr><th style="text-align: left">Rule symbol</th><th style="text-align: left">scitype suggestion</th></tr><tr><td style="text-align: left"><code>:few_to_finite</code></td><td style="text-align: left">an appropriate <code>Finite</code> subtype for columns with few distinct values</td></tr><tr><td style="text-align: left"><code>:discrete_to_continuous</code></td><td style="text-align: left">if not <code>Finite</code>, then <code>Continuous</code> for any <code>Count</code> or <code>Integer</code> scitypes/types</td></tr><tr><td style="text-align: left"><code>:string_to_multiclass</code></td><td style="text-align: left"><code>Multiclass</code> for any string-like column</td></tr></table><p>Autotype can be used in conjunction with <code>coerce</code>:</p><pre><code class="language-none">X_coerced = coerce(X, autotype(X))</code></pre><h3 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h3><p>By default it only applies the <code>:few_to_many</code> rule</p><pre><code class="language-julia">n = 50
X = (a = rand(&quot;abc&quot;, n),         # 3 values, not number        --&gt; Multiclass
     b = rand([1,2,3,4], n),     # 4 values, number            --&gt; OrderedFactor
     c = rand([true,false], n),  # 2 values, number but only 2 --&gt; Multiclass
     d = randn(n),               # many values                 --&gt; unchanged
     e = rand(collect(1:n), n))  # many values                 --&gt; unchanged
autotype(X, only_changes=true)</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s18} where #s18&lt;:Union{Missing, Found}} with 3 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :c =&gt; OrderedFactor</code></pre><p>For example, we could first apply the <code>:discrete_to_continuous</code> rule, followed by <code>:few_to_finite</code> rule. The first rule will apply to <code>b</code> and <code>e</code> but the subsequent application of the second rule will mean we will get the same result apart for <code>e</code> (which will be <code>Continuous</code>)</p><pre><code class="language-julia">autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s18} where #s18&lt;:Union{Missing, Found}} with 4 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :e =&gt; Continuous
  :c =&gt; OrderedFactor</code></pre><p>One should check and possibly modify the returned dictionary before passing to <code>coerce</code>.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 January 2020 06:15">Tuesday 14 January 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
